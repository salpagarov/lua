<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3 Руководство</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="css/lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="css/manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
</HEAD>

<BODY>
	<H1>
		<A HREF="index.html"><IMG SRC="images/logo.png" ALT="Lua"></A>
		Lua 5.3 Руководство
	</H1>
	<DIV CLASS="menubar">
		<A HREF="main.html#about">Lua</A> 
		&middot; <A HREF="main.html#documentation">Документация</A>
	</DIV>

<!-- ====================================================================== -->
<SMALL>
	<P>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes<br />
	перевел Ведерников Николай, Лысьва.</P>
</SMALL>
<p>

<!-- $Id: manual.of,v 1.151 2015/06/10 21:08:57 roberto Exp $ -->

<h1>1 &ndash; <a name="1">Введение</a></h1>

<p>
Lua - язык программирования расширений, разработан для поддержки
общего процедурного программирования с возможностью описания данных.
Lua также предлагает хорошую поддержку объектно-ориентированного,
функционального и управляемого данными (data-driven) программирования.
Lua предлагается как мощный и лёгкий встраиваемый скриптовый язык
для любой программы, которая в этом нуждается.
Lua реализован как библиотека, написан на <em>чистом C</em>, общее подмножетво
стандартного C и C++.

<p>
Как язык расширений, Lua не имеет понятия "главной" программы:
он работает только как <em>встроенный</em> в основную программу клиент,
<em>встраивающая программа</em> называется <em>хост</em> (host).
Встраивающая программа может вызывать функции для запуска кусочков Lua кода,
может писать и читать Lua переменные,
может регистрировать C-функции чтобы вызывать их из Lua кода.
Через использование С-функций Lua может быть расширен для решения различных задач,
таким образом созданные адаптированные языки программирования имеют общую синтаксическую базу.
Дистрибутив Lua включает простую хост-программу <code>lua</code>,
которая использует библиотеку Lua для реализации полного независимого Lua интерпретатора,
для интерактивного или пакетного использования.

<p>
Lua бесплатное программное обеспечение и предоставляется безо всяких гарантий.
Официальный сайт <code>www.lua.org</code>.

<p>
Как и любое другое руководство, это руководство местами сухо.
Описание решений принятых в основе дизайна Lua есть на технических страницах официального сайта.
Детальное введение в программирование на Lua представлено в книге
Роберто Иерусалимского <em>Programming in Lua</em>.


<h1>2 &ndash; <a name="2">Базовые концепции</a></h1>

<p>
Этот раздел описывает базовые концепции языка.


<h2>2.1 &ndash; <a name="2.1">Значения и типы</a></h2>

<p>
Lua <em>динамически типизированный язык</em>.
Это означает, что значения не имеют типов; только значения.
Язык не имеет определений типов.
Все значения несут свой собственный тип.

<p>
Все значения в Lua <em>первоклассные</em>.
Это означает что все значения могут быть сохранены в переменных,
переданы как аргументы другим функциям, и возвращены как результаты.

<p>
В Lua существует восемь базовых типов:
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em> и <em>table</em>.

<p>
Тип <em>nil</em> (нуль) имеет одно единственное значение, <b>nil</b>,
его главное свойство это отличаться от любых других значений;
обычно это означает отсутствие используемого значения.
<p>
Тип <em>boolean</em> (логический) имеет два значения: <b>false</b> (ложь) и <b>true</b> (истина).
Оба <b>nil</b> и <b>false</b> означают false;
любое другое значение означает true.
<p>
Тип <em>number</em> (число) представляет целые
(integer) и вещественные (float) числа.
<p>
Тип <em>string</em> (строка) представляет неизменные последовательности байт.

Строки в Lua могут содержать любое 8-битное значение,
включая нули ('<code>\0</code>').
Также Lua противник кодировок;
никаких предположений о содержимом строки не делается.

<p>
Тип <em>number</em> использует два внутренних представления,
или два подтипа,
один называется <em>integer</em> (целое), второй <em>float</em> (число с плавающей запятой).
Lua имеет явные правила о том, когда какое представление использовать,
но при необходимости автоматически конвертирует значение между ними (см. <a href="#3.4.3">&sect;3.4.3</a>).
Следовательно, в большистве случаев программист может игнорировать
разницу между целыми и реальными числами,
или получить полный контроль над представлением каждого числа.
Стандартный Lua использует 64-битные целые (integer) и вещественные числа двойной точности (double 64-bit),
но также возможно скомпилировать Lua так, чтобы использовались 
32-битные целые и/или вещественные числа одинарной точности (float 32-bit).
Эта опция с 32 битами для целых и вещественных чисел особенно актуальна
для малых машин и встроенных систем.
(Смотри макрос <code>LUA_32BITS</code> в файле <code>luaconf.h</code>.)

<p>
Lua может вызывать и манипулировать функциями написанными на Lua и на С (см. <a href="#3.4.10">&sect;3.4.10</a>).
Оба типа функций в Lua представлены типом <em>function</em> (функция).

<p>
Тип <em>userdata</em> (пользовательские данные) предназначен для хранения
произвольных С данных в Lua переменных.
Значение userdata представляет блок памяти (raw memory).
Существуют два типа пользовательских данных:
<em>full userdata</em> (полные пользовательские данные) -
объект с блоком памяти, которым управляет Lua,
и <em>light userdata</em> (лёгкие пользовательские данные) - простой С указатель.
Пользовательские данные не имеют предопределенных операторов в Lua,
кроме оператора присвоения и сравнения на идентичность.
Используя <em>метатаблицы</em>,
программист может определить операции для значений full userdata (см. <a href="#2.4">&sect;2.4</a>).
Значения userdata не могут быть созданы или изменены в Lua, это возможно только через C&nbsp;API.
Это гарантирует целостность данных, которыми владеет хост-программа.

<p>
Тип <em>thread</em> (поток) представляет независимый поток выполнения
и используется для реализации сопрограмм (coroutine) (см. <a href="#2.6">&sect;2.6</a>).
Lua потоки это не реальные потоки операционной системы.
Lua поддерживает сопрограммы на всех системах, даже на тех, где это не поддерживается операционной системой.

<p>
Тип <em>table</em> (таблица) реализует ассоциативные массивы,
это значит, что массив может быть проиндексирован не только числами,
но и любым Lua значением, кроме <b>nil</b> и NaN.
(<em>Not a Number</em> специальное значение для представления неопределенных и
непредставимых числовых результатов, таких как <code>0/0</code>.)
Таблицы могут быть <em>гетерогенными</em> (разнородными);
т.е. могут содержать значения всех типов (кроме <b>nil</b>).
Любой ключ со значением <b>nil</b> не считается частью таблицы.
И наоборот, любой ключ, не являющийся частью таблицы, имеет ассоциированное значение <b>nil</b>.

<p>
Таблицы единственный механизм структурирования данных в Lua;
они могут использоваться для представления обычных массивов, последовательностей,
таблиц символов, множеств, записей, графов, деревьев и т.п.
Для представления записей, Lua использует имена полей как индекс.
Язык поддерживает представление <code>a.name</code>, как синтаксическое украшение <code>a["name"]</code>.
Существуют различные пути создания таблиц в Lua
(см. <a href="#3.4.9">&sect;3.4.9</a>).

<p>
Мы используем термин <em>последовательность</em> (sequence)
чтобы обозначить таблицу, где все ключи это натуральные числа {1..<em>n</em>} (1,2,3,...),
где <em>n</em> - длина последовательности (см. <a href="#3.4.7">&sect;3.4.7</a>).

<p>
Как и индексы, значения полей в таблице могут быть любого типа.
В частности, т.к. функции это первоклассные значения,
поля таблицы могут содержать функции.
Такие таблицы также могут содержать <em>методы</em> (см. <a href="#3.4.11">&sect;3.4.11</a>).

<p>
Индексирование в таблицах следует принципу "сырого" (raw) равенства в языке.
Выражения <code>a[i]</code> и <code>a[j]</code>
определяют один и тот же элемент таблицы,
если и только если <code>i</code> и <code>j</code> равны (raw equal)
(значит, равны без метаметодов).
В частности, вещественные числа (float) с целыми значениями
равны соответствующим целым (integer), т.е., <code>1.0 == 1</code>.
Во избежание неоднозначностей, любое реальное число с целым значением, которое испльзуется как ключ,
конвертируется в соответствующее ему целое число.
Например, если написать <code>a[2.0] = true</code>,
фактически в таблицу будет вставлен целочисленный (integer) ключ <code>2</code>.
С другой стороны, 2 and "<code>2</code>" разные Lua значения и следовательно обозначают
разные данные в таблице.

<p>
Таблицы, функции, потоки и пользовательские данные (userdata) - это <em>объекты</em>:
переменные фактически не <em>содержат</em> их значений, только <em>ссылки</em> на них.
Присвоение, передача параметров и возврат из функций
всегда манипулируют ссылками на эти значения;
эти операции не подразумевают никакого типа копирования.

<p>
Библиотечная функция <a href="#pdf-type"><code>type</code></a>
возвращает строку с названием переданного ей типа (см. <a href="#6.1">&sect;6.1</a>).


<h2>2.2 &ndash; <a name="2.2">Окружения и глобальное окружение</a></h2>

<p>
Как будет описано в <a href="#3.2">&sect;3.2</a> и <a href="#3.3.3">&sect;3.3.3</a>,
любая ссылка на свободное имя
(т.е., имя не связанное ни с каким определением) <code>var</code>
синтаксически транслируется в <code>_ENV.var</code>.
Кроме того, каждый кусок (chunk) компилируется в области внешней локальной переменной,
называемой <code>_ENV</code> (см. <a href="#3.3.2">&sect;3.3.2</a>),
таким образом <code>_ENV</code> само никогда не бывает свободным именем в куске.

<p>
Несмотря на существование этой внешней переменной <code>_ENV</code> и 
трансляцию свободных имен,
<code>_ENV</code> полностью регулярное имя.
В частности, вы можете определить новые переменные и параметры с этим именем.
Каждая ссылка на свободное имя использует <code>_ENV</code>, которая видима
в данной точке программы, следуя обычным правилам видимости Lua (см. <a href="#3.5">&sect;3.5</a>).

<p>
Любая таблица, используемая как значение переменной <code>_ENV</code>,
называется <em>окружение</em> (environment).

<p>
Lua хранит особое окружение, называемое <em>глобальное окружение</em>.
Это значение хранится по специальному индексу в С реестре (см. <a href="#4.5">&sect;4.5</a>).
В Lua, глобальная переменная <a href="#pdf-_G"><code>_G</code></a> инициализируется тем же значением.
(<a href="#pdf-_G"><code>_G</code></a> никогда не используется непосредственно.)

<p>
Когда Lua загружает кусок (chunk),
по умолчанию его <code>_ENV</code> upvalue присваивается значение глобального окружения
(см. <a href="#pdf-load"><code>load</code></a>).
Следовательно, по умолчанию,
свободные имена в Lua коде ссылаются на элементы в глобальном окружении
(и, следовательно, они также называются <em>глобальными переменными</em>).
Кроме того, все стандартные библиотеки загружаются в глобальное окружение
и некоторые их функции действуют в этом окружении.
Вы можете использовать <a href="#pdf-load"><code>load</code></a> (или <a href="#pdf-loadfile"><code>loadfile</code></a>)
для загрузки куска с другим окружением.
(В C, вы загружаете кусок и затем изменяете его первое upvalue.)


<h2>2.3 &ndash; <a name="2.3">Обработка ошибок</a></h2>

<p>
Так как Lua встроенный язык расширений,
все Lua действия начинаются с C&nbspкода;
код в хостовой программе вызывает функцию в Lua библиотеке.
(При использовании автономного интерпретатора Lua,
программа <code>lua</code> выступает в качестве хоста.)
Всякий раз, когда происходит ошибка компиляции или выполнения куска Lua кода,
управление возвращается хостовой программе,
которая может предпринять соответствующие меры
(такие как печать сообщения об ошибке).

<p>
Lua код может явно сгенерировать ошибку, вызвав функцию
<a href="#pdf-error"><code>error</code></a>.
Если вы нуждаетесь в перехвате ошибок в Lua,
вы можете использовать <a href="#pdf-pcall"><code>pcall</code></a> или
<a href="#pdf-xpcall"><code>xpcall</code></a>
для вызова функции в <em>защищенном режиме</em>.

<p>
При каждой ошибке, создается 
<em>объект ошибки</em> (также называемый <em>сообщением об ошибке</em>)
с информацией об ошибке.
Самостоятельно Lua генерирует только те ошибки, где объект ошибки содержит строку,
но программы могут генерировать ошибки с любым значением в объекте ошибки.
Объекты ошибки (исключения) пробрасываются вверх в Lua или в хост для обработки.

<p>
Когда вы используете <a href="#pdf-xpcall"><code>xpcall</code></a> или <a href="#lua_pcall"><code>lua_pcall</code></a>,
вы можете определить <em>обработчик сообщений</em>,
который будет вызываться в случае ошибок.
Эта функция вызывается с оригинальным сообщением об ошибке и
возвращает новое сообщение об ошибке.
Она вызывается до раскрутки стека,
так она сможет получить больше информации об ошибке,
например, проверяя стек и создавая историю стека (stack traceback).
Этот обработчик сообщений остается защищенным в защищенном вызове;
так, ошибка в обработчике сообщений лишь вызовет его снова.
Если этот цикл будет достаточно длинным,
Lua прервет его и вернет соответствующее сообщение.


<h2>2.4 &ndash; <a name="2.4">Метатаблицы и метаметоды</a></h2>

<p>
Каждое значение в Lua может иметь <em>метатаблицу</em>.
Эта <em>метатаблица</em> обычная Lua таблица,
которая определяет поведение оригинального значения
в определенных специальных операциях.
Вы можете изменять различные аспекты поведения
в операциях со значением, изменяя специфические поля в метатаблице.
Например, когда не цифровое значение является операндом в сложении,
Lua проверяет есть ли в его метатаблице поле "<code>__add</code>" с функцией.
И, если оно существует, Lua вызывает эту функцию для выполнения сложения.

<p>
Ключи в метатаблице это производные от имен <em>событий</em>;
соответствующие им значения называются <em>метаметоды</em>.
В предыдущем примере, событие - <code>"add"</code> (добавить)
и метаметод - функция, которая выполняет сложение.

<p>
Вы можете запросить метатаблицу любого значения, используя функцию
<a href="#pdf-getmetatable"><code>getmetatable</code></a>.

<p>
Вы можете заменить метатаблицу таблицы, используя <a href="#pdf-setmetatable"><code>setmetatable</code></a>.
Нельзя изменять метатаблицы других типов из Lua кода
(кроме, как используя библиотеку отладки (<a href="#6.10">&sect;6.10</a>));
для этого вы должны использовать C&nbsp;API.

<p>
Таблицы и полные пользовательские данные (full userdata) имеют индивидуальные метатаблицы
(хотя таблицы и пользовательские данные могут совместно использовать свои метатаблицы).
Значения остальных типов используют одну метатаблицу на тип;
т.е, существует одна метатаблица для всех чисел, одна для всех строк и т.д.
По умолчанию, значения не имеют метатаблицу,
но строковая библиотека создает метатаблицу для строкового типа (см. <a href="#6.4">&sect;6.4</a>).

<p>
Метатаблица контролирует, как объект ведет себя в арифметических и битовых операциях,
сравнениях при сортировке, конкатенации, определении длины, вызовах и индексировании.
Метатаблица также может определять функцию, которая будет вызвана
для таблицы или пользовательских данных при уничтожении сборщиком мусора
(<a href="#2.5">&sect;2.5</a>).

<p>
Детальное описание событий, контролируемых метатаблицами, представлено ниже.
Каждая операция идентифицируется соответсвующим именем события.
Ключ для каждого события это строка начинающаяся с двух подчеркиваний, '<code>__</code>';
например, ключ для операции "add" строка "<code>__add</code>".
Имейте ввиду, что запросы метаметодов всегда прямые;
доступ к метаметоду не запускает других метаметодов

<p>
Для одноместных операторов (отрицание, длина и битовое отрицание),
метаметод вычисляется и вызывается с фиктивным вторым операндом,
равным первому.
Этот дополнительный операнд нужен лишь для упрощения реализации Lua,
и может быть убран в следующих версиях.
(Для большинства применений этот дополнительный операнд несущественнен.)

<ul>

<li><b>"add": </b>
<code>+</code> операция.

Если любой операнд при сложении не число
(и не строка, которую можно преобразовать в число),
Lua попробует вызвать метаметод.
Сначала, Lua проверит первый операнд (даже если он правильный).
Если этот операнд не определяет метаметод для события "<code>__add</code>",
Lua проверит второй операнд.
Если Lua найдет метаметод, он будет вызван с двумя операндами в качестве аргументов,
и результат вызова
(скорректированный до одного значения)
будет результатом операции.
Иначе будет сгенерирована ошибка.
</li>

<li><b>"sub": </b>
<code>-</code> операция (вычитание). Аналогично операции "add".
</li>

<li><b>"mul": </b>
<code>*</code> операция (умножение). Аналогично операции "add".
</li>

<li><b>"div": </b>
<code>/</code> операция (деление). Аналогично операции "add".
</li>

<li><b>"mod": </b>
<code>%</code> операция (остаток от деления). Аналогично операции "add".
</li>

<li><b>"pow": </b>
<code>^</code> операция (возведение в степень). Аналогично операции "add".
</li>

<li><b>"unm": </b>
<code>-</code> операция (одноместный минус). Аналогично операции "add".
</li>

<li><b>"idiv": </b>
<code>//</code> операция (целочисленное деление). Аналогично операции "add".
</li>

<li><b>"band": </b>
<code>&amp;</code> операция (битовое И). Аналогично операции "add",
за исключением того, что Lua будет использовать метаметод, если любой из операндов
не целое и не значение приводимое к целому (см. <a href="#3.4.3">&sect;3.4.3</a>).
</li>

<li><b>"bor": </b>
<code>|</code> операция (битовое ИЛИ). Аналогично операции "band".
</li>

<li><b>"bxor": </b>
<code>~</code> операция (битовое ИЛИ-НЕ). Аналогично операции "band".
</li>

<li><b>"bnot": </b>
<code>~</code> операция (битовое одноместное НЕ). Аналогично операции "band".
</li>

<li><b>"shl": </b> 
<code>&lt;&lt;</code> операция (битовый сдвиг влево). Аналогично операции "band".
</li>

<li><b>"shr": </b>
<code>&gt;&gt;</code> операция (битовый сдвиг вправо). Аналогично операции "band".
</li>

<li><b>"concat": </b>
<code>..</code> операция (конкатенация). Аналогично операции "add",
за исключением того, что Lua будет использовать метаметод, если любой из операндов
не строка и не число (которое всегда приводимо к строке).
</li>

<li><b>"len": </b>
<code>#</code> операция (длина).
Если объект не строка, Lua попытается использовать этот метаметод;
Если метаметод определен, он будет вызван с объектом в качестве аргумента,
и результат вызова (обрезанный до одного значения)
будет использован как результат операции.
Если метаметод не определен и объект таблица, Lua использует
операцию длины таблицы (см. <a href="#3.4.7">&sect;3.4.7</a>).
Иначе, Lua сгенерирует ошибку.
</li>

<li><b>"eq": </b>
<code>==</code> операция (равенство). Аналогично операции "add",
за исключением того, что Lua будет использовать метаметод,
только если оба сравниваемых значения таблицы или полные пользовательские данные
и они не примитивно равны.
Результат вызова всегда преобразуется к логическому (boolean).
</li>

<li><b>"lt": </b>
<code>&lt;</code> операция (меньше). Аналогично операции "add",
за исключением того, что Lua будет использовать метаметод,
только если оба сравниваемых значения не числа и не строки.
Результат вызова всегда преобразуется к логическому (boolean).
</li>

<li><b>"le": </b>
<code>&lt;=</code> операция (меньше или равно).
В отличие от других операций, операция "<=" может использовать два разных события.
Первое, Lua проверяет наличие метаметода "<code>__le</code>" в обоих операндах,
также как в операции "lt".
Если этот метаметод не найден, Lua попытается использовать событие "<code>__lt</code>",
предполагая, что <code>a &lt;= b</code> эквивалентно <code>not (b &lt; a)</code>.
Как и у других операторов сравнения, результат всегда логическое значение.
(Это использование события "<code>__lt</code>" может быть убрано в следующих версиях,
т.к. оно медленнее, чем реальный вызов метаметода "<code>__le</code>".)
</li>

<li><b>"index": </b>
индексированный доступ <code>table[key]</code>.
Это событие случается когда <code>table</code> не таблица или
когда <code>key</code> не существует в <code>table</code>.
Метаметод ищется в объекте <code>table</code>.

<p>
Несмотря на имя, метаметод для этого события может быть функцией или таблицей.
Если это функция, то она вызывается с <code>table</code> и <code>key</code> в качестве аргументов.
Если таблица, то конечный результат это результат индексирования этой таблицы с ключом <code>key</code>.
Это индексирование регулярное, не прямое, и оно также может вызывать срабатывание другого метаметода.
</li>

<li><b>"newindex": </b>
индексированное присваивание <code>table[key] = value</code>.

Как и событие "index", это событие случается когда <code>table</code> не таблица или
когда <code>key</code> не существует в <code>table</code>.
Метаметод ищется в объекте <code>table</code>.

<p>
Как и для индексированного доступа, метаметод для этого события может быть функцией или таблицей.
Если это функция, то она вызывается с <code>table</code>, <code>key</code> 
и <code>value</code> в качестве аргументов.
Если таблица, Lua производит индексированное присваивание для этой таблицы с тем же ключом и значением.
Это присваивание регулярное, не прямое, и оно также может вызывать срабатывание другого метаметода.

<p>
Всякий раз, когда срабатывает метаметод "newindex",
Lua не выполняет примитивное присваивание.
(Если необходимо,
метаметод может самостоятельно вызвать <a href="#pdf-rawset"><code>rawset</code></a>
для выполнения присваивания.)
</li>

<li><b>"call": </b>
операция вызова <code>func(args)</code>.
Это событие случается когда Lua пытается вызвать значение, не являющееся функцией
(т.е., <code>func</code> это не функция).
Метаметод ищется в объекте <code>func</code>.
Если он существует, то он вызывается с <code>func</code> в качестве первого аргумента,
следом идут остальные аргументы из оригинального вызова (<code>args</code>).
</li>

</ul>

<p>
Хорошая практика, добавлять все необходимые метаметоды в таблицу
перед тем, как назначить её метатаблицей какого-то объекта.
В частности, метаметод "<code>__gc</code>" работает только если была соблюдена эта последовательность
(см. <a href="#2.5.1">&sect;2.5.1</a>).


<h2>2.5 &ndash; <a name="2.5">Сборка мусора</a></h2>

<p>
Lua выполняет автоматическое управление памятью.
Это означает, что вы не должны беспокоиться о выделении памяти новым объектам
или об освобождении памяти, когда объекты больше не нужны.
Lua управляет памятью, запуская <em>сборщик мусора</em>
для сборки всех <em>мёртвых объектов</em>
(т.е., объектов более не доступных из Lua).
Вся память, используемая Lua, подлежит автоматическому управлению:
строки, таблицы, пользовательские данные, функции, потоки, внутренние структуры и т.д.

<p>
Lua реализует пошаговый отмечающий-и-очищающий сборщик.
Для контроля циклов очистки мусора используются два числа:
<em>пауза сборщика мусора</em> и
<em>множитель шагов сборщика мусора</em>.
Оба числа используют процентные пункты как единицы
(т.е., значение 100 означает внутреннее значение 1).

<p>
Пауза сборщика мусора контролирует, как долго сборщик ждет перед началом нового цикла.
Чем больше значение, тем менее агрессивен сборщик.
Значения меньше 100 означают, что сборщик не останавливается перед началом
нового цикла.
Значение 200 означает, что сборщик, перед тем как начать новый цикл,
ждет повышения использования общей памяти в два раза.

<p>
Множитель шагов сборщика мусора
контролирует относительную скорость сборщика по отношению к скорости выделения памяти.
Большие значения делают сборщик более агрессивным, но также
увеличивают размер каждого шага.
Вы не должны использовать значения меньше 100,
т.к. они сделают сборщик настолько медленным, что он никогда
не завершит цикл.
По умолчанию, используется значение 200,
которое означает, что сборщик выполняется в два раза быстрее
скорости выделения памяти.

<p>
Если вы установите множитель шагов очень большым
(больше чем 10% от максимального числа байт, которые может использовать программа),
сборщик поведет себя как останавливающий мир.
Если вы установите паузу 200,
сборщик будет вести себя как в старых версиях Lua,
производя полную очистку каждый раз, когда Lua удваивает использование памяти.

<p>
Вы можете изменять эти числа, вызывая <a href="#lua_gc"><code>lua_gc</code></a> в C
или <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> в Lua.
Вы также можете использовать эти функции для прямого контроля сборщика
(т.е., его остановки и перезапуска).


<h3>2.5.1 &ndash; <a name="2.5.1">Метаметоды сборки мусора</a></h3>

<p>
Вы можете установить метаметоды сборки мусора для таблиц и,
используя C&nbsp;API, для полных пользовательских данных (см. <a href="#2.4">&sect;2.4</a>).
Эти метаметоды также называются <em>деструкторы</em> (finalizers).
Деструкторы позволяют координировать сборку мусора в Lua с
внешним управлением ресурсами
(таким как закрытие файлов, сетевый подключения, подключения к базам данных
или освобождение вашей памяти).

<p>
Для объекта (таблицы или пользовательских данных) чтобы быть уничтоженным при сборке мусора,
вы должны <em>отметить</em> его на уничтожение.

Вы отмечаете объект на уничтожение, когда устанавливаете для него метатаблицу,
содержащую поле "<code>__gc</code>".
Имейте ввиду, что если вы установите метатаблицу без поля <code>__gc</code>
и затем создадите это поле в метатаблице,
то объект не будет отмечен на уничтожение.

<p>
Когда отмеченный объект становится мусором,
он не уничтожается напрямую сборщиком мусора.
Вместо этого, Lua ложит его в список.
После завершения сборки, Lua проходит по этому списку.
Для каждого объекта в списке проверяется метаметод <code>__gc</code>:
если это функция, Lua вызывает её с объектом в качестве единственного аргумента;
если метаметод не функция, Lua просто игнорирует его.

<p>
В конце каждого цикла сборки мусора,
деструкторы объектов вызываются в порядке обратном
порядку их отметки на уничтожение;
т.е., первым деструктор будет вызван для последнего отмеченного на уничтожение объекта.
Выполнение каждого деструктора может произойти в любое время при выполнении основного кода.

<p>
Так как объект подлежащий уничтожению должен быть использован в деструкторе,
этот объект (и остальные объекты доступные через него)
должны быть <em>воскрешены</em> Lua.
Обычно, это воскрешение нерезидентно,
и память объекта освобождается при следующем цикле сборки мусора.
Тем не менее, если деструктор сохраняет объект в каком-то глобальном месте
(т.е. глобальной переменной), воскрешение постоянно.
Более того, если деструктор отмечает уничтожаемый объект для уничтожения снова,
его деструктор будет вызван снова в следующем цикле, где объект не доступен.
В любом случае, память объекта освобождается только в цикле сборки мусора, где
объект недоступен и не отмечен на уничтожение через деструктор.

<p>
Когда вы закрываете контекст (см. <a href="#lua_close"><code>lua_close</code></a>),
Lua вызывает деструкторы всех объектов отмеченных на уничтожение,
следуя порядку обратному порядку их отметки на уничтожение.
Если любой деструктор отмечает объекты для уничтожения в этой фазе,
эти отметки не имеют никакого эффекта.


<h3>2.5.2 &ndash; <a name="2.5.2">Слабые таблицы</a></h3>

<p>
<em>Слабая таблица</em> (weak table) - это таблица, элементы которой
это <em>слабые ссылки</em> (weak references).
Слабая ссылка игнорируется сборщиком мусора.
Другими словами,
если на объект существуют только слабые ссылки,
то объект будет уничтожен сборщиком мусора.

<p>
Слабая таблица может иметь слабые ключи, слабые значения или и то и другое.
Таблица со слабыми значениями позволяет уничтожать её значения,
но препятствует уничтожению её ключей.
Таблица со слабыми значениями и ключами позволяет уничтожать и ключи и значения.
В любом случае, если ключ или значение уничтожены, эта пара удаляется из таблицы.
Слабость таблицы контролируется полем <code>__mode</code> в её метатаблице.
Если поле <code>__mode</code> это строка содержащая символ &nbsp;'<code>k</code>',
в таблице слабые ключи.
Если поле <code>__mode</code> содержит '<code>v</code>',
в таблице слабые значения.

<p>
Таблица со слабыми ключами и сильными значениями
называется <em>эфемерной таблицей</em> (ephemeron table).
В эфемерной таблице, значение достижимо только если его ключ достижим.
В частности, если ссылка на ключ приходит через его значение, пара удаляется.

<p>
Любое изменение слабости таблицы будет иметь эффект только в следующем цикле сборки мусора.
В частности, если вы сменили слабый на сильный режим,
Lua может продолжить сбор некоторых элементов из этой таблицы,
пока изменения не будут иметь эффект.

<p>
Только объекты, имеющие явную конструкцию,
удаляются из слабых таблиц.
Значения, такие как числа и легкие C функции,
не являются субъектами для сборки мусора,
и следовательно не удаляются из слабых таблиц
(пока их ассоциированные значения не удалены).
Хотя строки субъекты для сборки мусора,
они не имеют явную конструкцию, и следовательно не удаляются из слабых таблиц.

<p>
Воскрешенные объекты
(т.е., объекты подлежащие уничтожению и объекты достпупные через них)
имеют специальное поведение в слабых таблицах.
Они удаляются из слабых значений перед запуском их деструкторов,
но удаляются из слабых ключей только в следующем цикле сборки,
после запуска их деструкторов, когда эти объекты действительно освобождены.
Это поведение позволяет деструктору получить доступ к свойствам,
ассоциированным с объектом через слабые таблицы.

<p>
Если слабая таблица среди воскрешенных объектов в цикле сборки,
она не может быть правильно очищена до следующего цикла сборки.


<h2>2.6 &ndash; <a name="2.6">Сопрограммы</a></h2>

<p>
Lua поддерживает сопрограммы,
так называемую <em>совместную многопоточность</em>.
Сопрограмма в Lua представляет независимый поток выполнения.
В отличе от потоков в многопоточных системах, 
сопрограммма прерывает свое исполнение только явным вызовом функции yield (уступить).

<p>
Сопрограмма создается функцией <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>.
Единственный аргумент функции это главная функция сопрограммы.
Функция <code>create</code> только создает сопрограмму и возвращает её описатель
(объект типа <em>thread</em> - поток);
она не запускает сопрограмму.

<p>
Сопрограмма запускается вызовом <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
При первом вызове <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
в качестве первого аргумента передается поток,
возвращенный функцией <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
сопрограмма начинает свое исполнение с вызова своей главной функции.
Дополнительные аргументы, переданные в <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
передаются как аргументы этой функции.
После запуска сопрограммы, она выполняется пока не будет завершена или не <em>уступит</em> (yield).

<p>
Сопрограмма может завершить свое исполнение двумя путями:
нормально, когда её главная функция вернет управление
(явно или не явно, после последней инструкции);
и ненормально, если произойдет незащищенная ошибка.

В случае нормального завершения,
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> вернет <b>true</b> и
значения, возвращенные главной фунцией сопрограммы.

В случае ошибок, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> вернет <b>false</b>
и сообщение об ошибке.

<p>
Сопрограмма уступает, вызывая <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
Когда сопрограмма уступает,
соответсвующая <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> немедленно возвращает управление,
даже если уступка случилась внутри вложенной функции
(т.е., не в главной функции, а в функции прямо или косвенно вызванной из главной функции).
В случае уступки, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> также возвращает <b>true</b>
и значения, переданные в <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
В следующий раз, возобновление этой же сопрограммы
продолжает её выполнение с точки, где она уступила вызовом
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>,
возвращающим дополнительные аргументы, переданные в 
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.

<p>
Как и <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
функция <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> создает сопрограмму,
но вместо сопрограммы возвращает функцию, вызов которой возобновляет сопрограмму.
Аргументы, переданные этой функции, идут как дополнительные аргументы в
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> возвращает все
значения полученные от <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
кроме первого (логический код ошибки).
В отличие от <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> не перехватывает ошибки;
все ошибки передаются вызывающей стороне.

<p>
Для примера работы сопрограммы, рассмотрите следующий код:

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
Запустив его, вы получите следующий результат:

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
Вы также можете создавать и манипулировать сопрограммами через C API:
см. функции <a href="#lua_newthread"><code>lua_newthread</code></a>, <a href="#lua_resume"><code>lua_resume</code></a>
и <a href="#lua_yield"><code>lua_yield</code></a>.


<h1>3 &ndash; <a name="3">Язык</a></h1>

<p>
Этот раздел описывает лексику, синтаксис и семантику Lua.
Другими словами, этот раздел описывает какие лексемы (tokens) правильны,
как они могут быть скомбинированы, и что их комбинации означают.

<p>
Языковые конструкции будут объясняться используя обычную расширенную БНФ нотацию,
в которой {<em>a</em>}&nbsp;означает&nbsp;0 или больше <em>a</em>, и
[<em>a</em>]&nbsp;означает опциональную <em>a</em>.
Нетерминалы показаны как non-terminal,
ключевые слова показаны как <b>kword</b>,
и другие терминальные символы показаны как &lsquo;<b>=</b>&rsquo;.
Полный синтасис Lua описан в <a href="#9">&sect;9</a> в конце руководства.


<h2>3.1 &ndash; <a name="3.1">Лексические соглашения</a></h2>

<p>
Lua - это язык свободной формы.
Он игнорирует пробелы (включая переходы на новую строку) и комментарии
между лексическими элементами, кроме разделителей между именами и ключевыми словами.

<p>
<em>Имена</em>
(также называемые <em>идентификаторами</em>)
в Lua могут быть любой строкой из букв, цифр и подчеркиваний,
не начинающейся с цифры.
Идентификаторы используются для именования значений, полей таблиц и меток (labels).

<p>
Следующие <em>ключевые слова</em> зарезервированы
и не могут использоваться как имена:

<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Язык Lua чувствителен к регистру символов:
<code>and</code> - зарезервированное слово, но <code>And</code> и <code>AND</code>
- два разных, допустимых имени.

Как соглашение, программы должны избегать создания имен,
которые начинаются с подчеркивания и следующими за ним одной или несколькими
прописными буквами (например, <a href="#pdf-_VERSION"><code>_VERSION</code></a>).

<p>
Следующие строки разделяют другие лексемы:

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>Литеральные строки</em>
могут быть ограничены сочетающимися одинарными или двойными кавычками,
и могут содержать С-подобные управляющие последовательности:
'<code>\a</code>' (bell),
'<code>\b</code>' (backspace),
'<code>\f</code>' (form feed),
'<code>\n</code>' (newline),
'<code>\r</code>' (carriage return),
'<code>\t</code>' (horizontal tab),
'<code>\v</code>' (vertical tab),
'<code>\\</code>' (backslash),
'<code>\"</code>' (двойная кавычка)
и '<code>\'</code>' (апостроф [одинарная кавычка]).
Обратный слеш, сопровождаемый реальным переходом на новую строку (newline),
формирует переход строки (newline) в строке (string).
Управляющая последовательность '<code>\z</code>' пропускает следующий за ней диапазон
пробелов, включая переходы строки;
это особенно полезно, чтобы разбить и отступить длинную литеральную строку
на несколько линий без добавления переводов строки и пробелов
в содержимое строки.

<p>
Строки в Lua могут содержать любое 8-битное значение, влючая встроенные нули,
которые могут быть записаны как '<code>\0</code>'.
Более того, возможно описать любой байт в литеральной строке его числовым значением.
Это может быть сделано с помощью управляющей последовательности <code>\x<em>XX</em></code>,
где <em>XX</em> - это пара шестнадцатиричных цифр,
или с помощью <code>\<em>ddd</em></code>,
где <em>ddd</em> - последовательность до трех десятичных цифр.
(Обратите внимание, что если десятичная управляющая последовательность сопровождается цифрой,
то она должна содержать ровно три цифры.)

<p>
Unicode-символ в кодировке UTF-8
может быть вставлен в литеральную строку
с помощью последовательности <code>\u{<em>XXX</em>}</code>
(обратите внимание на обязательные фигурные скобки),
где <em>XXX</em> - это одна или больше шестнадцатиричных цифр
описывающих код символа.

<p>
Литеральные строки также могут быть определены используя <em>длинные скобки</em>.
Мы определяем <em>открывающую длинную скобку уровня <em>n</em></em>, как открывающую
квадратную скобку, следующие за ней <em>n</em> знаков = и ещё одну открывающую квадратную скобку.
Так, открывающая длинная скобка уровня&nbsp;0 запишется так: <code>[[</code>, 
для уровня 1 - <code>[=[</code>, и так далее.
<em>Закрывающая длинная скобка</em> определяется аналогично;
например,
закрывающая длинная скобка уровня&nbsp;4 запишется так: <code>]====]</code>.
<em>Длинный литерал</em> начинается с открывающей длинной скобки любого уровня
и завершается на первой закрывающей длинной скобке того же уровня.
Это позволяет содержать любой текст, кроме закрывающей скобки того же уровня.
Литералы в такой скобочной форме могут занимать несколько линий (строк),
управляющие последовательности в таких строках не работают,
длинные скобки других уровней игнорируются.
Любой вид последовательности завершения строки
(\r, \n, \r\n или \n\r) конвертируется в простой перевод строки \n.

<p>
Любой байт в литеральной строке не подвержен влиянию правил своего представления.
Тем не менее, Lua открывает файлы для парсинга в текстовом режиме,
и функции системы могут иметь проблемы с некоторыми управляющими символами.
Поэтому, для безопасного представления не текстовых данных в строке,
следует использовать управляющие последовательности.

<p>
Для удобства,
когда открывается длинная скобка с непосредственным переводом строки за ней,
перевод строки не включается в результирующую строку.
Например, в системе использующей ASCII
(в которой '<code>a</code>' кодируется как&nbsp;97,
newline кодируется как&nbsp;10 и '<code>1</code>' кодируется как&nbsp;49),
пять литеральных строк ниже кодируют одинаковые строки:

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>Числовая константа</em> (или <em>цифра</em>)
может быть записана с опциональной дробной частью
и опциональной десятичной экспонентой,
обозначенной буквой '<code>e</code>' или '<code>E</code>'.
Lua также поддерживает шестнадцатиричные константы,
которые начинаются с <code>0x</code> или <code>0X</code>.
Шестнадцатиричные константы также допускают использование дробной части
и бинарной экспоненты,
обозначеной буквой '<code>p</code>' или '<code>P</code>'.
Цифровая константа с разделительной точкой или экспонентой означает вещественное число;
иначе она означает целое.
Примеры допустимых целых чисел:

<pre>
     3   345   0xff   0xBEBADA
</pre><p>
Примеры допустимых вещественных чисел:

<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
<em>Комментарии</em> начинаются с двойного тире (<code>--</code>)
в любом месте за пределами литеральной строки.
Если текст, непосредственно следующий за <code>--</code>, не открывающая длинная скобка,
то это <em>короткий комментарий</em>, который продолжается до конца строки.
Иначе, это <em>длинный комментарий</em>,
который продолжается до соответствующей закрывающей длинной скобки.
Длинные комментарии часто используются для временного отключения кода.


<h2>3.2 &ndash; <a name="3.2">Переменные</a></h2>

<p>
Переменные - это место где хранятся значения.
Существует три вида переменных:
глобальные переменные, локальные переменные и поля таблиц.

<p>
Одно имя может означать глобальную или локальную переменную
(или формальный параметр функции, который является частным случаем локальной переменной):

<pre>
	var ::= Name
</pre><p>
Name означает идентификаторы, как описано в <a href="#3.1">&sect;3.1</a>.

<p>
Любое имя переменной предполагается глобальным,
пока явно не определено локальным (см. <a href="#3.3.7">&sect;3.3.7</a>).
Локальные переменные <em>лексически ограниченные</em>:
локальные переменные свободно доступны функциям,
определенным внутри их области видимости (см. <a href="#3.5">&sect;3.5</a>).

<p>
Перед первым присваиванием переменной, её значение равно <b>nil</b>.

<p>
Квадратные скобки используются для индексирования в таблице:

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
Значение доступа к полям таблицы может быть изменено через метатаблицы.
Доступ к индексированной переменной <code>t[i]</code> эквивалентно
вызову <code>gettable_event(t,i)</code>.
(См. <a href="#2.4">&sect;2.4</a> для полного описания функции <code>gettable_event</code>.
Эта функция не определена и не используется в Lua.
Мы используем её только для пояснения.)

<p>
Синтаксис <code>var.Name</code> - это лишь семантическое украшение для
<code>var["Name"]</code>:

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
Доступ к глобальной переменной <code>x</code>
эквивалентен <code>_ENV.x</code>.
в силу того, что блоки компилируются,
<code>_ENV</code> никогда не является глобальным именем (см. <a href="#2.2">&sect;2.2</a>).


<h2>3.3 &ndash; <a name="3.3">Выражения</a></h2>

<p>
Lua поддерживает почти стандартный набор выражений,
подобный наборам в Pascal или C.
Этот набор включает в себя
присваивания, управляющие структуры, вызовы функций и определения переменных.


<h3>3.3.1 &ndash; <a name="3.3.1">Блоки</a></h3>

<p>
Блок - это список выражений, которые выполняются последовательно:

<pre>
	block ::= {stat}
</pre><p>
Lua допускает <em>пустые выражения</em>,
что позволяет вам разделять выражения с помощью точки с запятой (;),
начинать блок с точки с запятой или
писать две точки с запятой подряд:

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
Вызовы функций и присваивания могут начинаться с открывающейся скобки.
Эта возможность ведет к неоднозначности в грамматике Lua.
Рассмотрим следующий фрагмент:

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
Грамматика может рассматривать это двумя путями:

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
Текущий парсер всегда рассматривает такие констркции первым путем,
интерпретируя открывающуюся скобку, как начало аргументов для вызова.
Для избежания этой неоднозначности,
лучше всегда ставить точку с запятой (;) перед
выражениями начинающимися со скобок:

<pre>
     ;(print or io.write)('done')
</pre>

<p>
Блок может быть явно выделен для создания единственного выражения:

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
Явные блоки полезны для контроля за областью видимости переменных.
Явные блоки также иногда используются для добавления выражения <b>return</b>
в середину другого блока (см. <a href="#3.3.4">&sect;3.3.4</a>).


<h3>3.3.2 &ndash; <a name="3.3.2">Куски</a></h3>

<p>
Единица компиляции в Lua называется <em>куском</em> (chunk).
Синтаксически, кусок это простой блок:

<pre>
	chunk ::= block
</pre>

<p>
Lua обрабатывает кусок, как тело анонимной функции с переменным числом аргументов
(см. <a href="#3.4.11">&sect;3.4.11</a>).
Как таковой, кусок может определять локальные переменные,
получать аргументы и возвращать значения.
Более того, такая анонимная функция компилируется в области видимости
внешней локальной переменной <code>_ENV</code> (см. <a href="#2.2">&sect;2.2</a>).
Результирующая функция всегда имеет <code>_ENV</code>,
как только свою upvalue,
даже если не использует эту переменную.

<p>
Кусок может храниться в файле или в строке внутри хостовой программы.
Для запуска куска,
Lua сперва <em>загружает</em> его (load),
прекомпилируя код куска в инструкции виртуальной машины,
и затем запускает скомпилированный код.

<p>
Кусок также может быть прекомпилирован в бинарную форму;
смотри программу <code>luac</code> и функцию <a href="#pdf-string.dump"><code>string.dump</code></a>.
Программы в исходном коде и в скомпилированной форме взаимозаменяемы;
Lua автоматически определяет тип файла и действует соответственно (см. <a href="#pdf-load"><code>load</code></a>).


<h3>3.3.3 &ndash; <a name="3.3.3">Присваивание</a></h3>

<p>
Lua позволяет множественные присваивания.
Синтаксис присваивания определяет список переменных с левой строны
и список выражений с правой стороны.
Элементы в обоих списках разделяются запятыми:

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
Выражения обсуждаются в <a href="#3.4">&sect;3.4</a>.

<p>
Перед присваиванием,
список значений <em>корректируется</em> до длины списка переменных.
Если значений больше чем нужно,
лишние значения отбрасываются.
Если значений меньше чем нужно,
список расширяется добавлением необходимого числа значений <b>nil</b>.
Если список выражений заканчивается вызовом функции,
все значения, возвращенные этой функцией, попадают в список значений
перед присваиванием.
(кроме вызова заключенного в скобки; см. <a href="#3.4">&sect;3.4</a>).

<p>
Оператор присваивания сперва вычисляет все свои выражения
и лишь затем выполняет присваивание.

Таким образом код
<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
устанавливает <code>a[3]</code> равным 20, не изменяя <code>a[4]</code>,
т.к. <code>i</code> в <code>a[i]</code> вычисляется (= 3)
до присваивания ему&nbsp;4.
Аналогично, строка

<pre>
     x, y = y, x
</pre><p>
меняет местами значения <code>x</code> и <code>y</code>,
и

<pre>
     x, y, z = y, z, x
</pre><p>
циклически переставляет значения <code>x</code>, <code>y</code> и <code>z</code>.

<p>
Значение присваиваний глобальным переменным и полям таблиц может быть изменено
через метатаблицы.
Присваивание индексированной переменной <code>t[i] = val</code>
эквивалентно <code>settable_event(t,i,val)</code>.
(См. <a href="#2.4">&sect;2.4</a> для полного описания функции <code>settable_event</code>.
Эта функция не определена и не используется в Lua.
Мы используем её только для пояснения.)

<p>
Присванивание глобальной переменной <code>x = val</code>
эквивалентно присваиванию
<code>_ENV.x = val</code> (см. <a href="#2.2">&sect;2.2</a>).


<h3>3.3.4 &ndash; <a name="3.3.4">Управляющие конструкции</a></h3><p>
Управляющие конструкции
<b>if</b>, <b>while</b> и <b>repeat</b> имеют обычное значение
и знакомый синтаксис:

<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua также имеет две формы оператора <b>for</b> (см. <a href="#3.3.5">&sect;3.3.5</a>).

<p>
Условное выражение в управляющей конструкции может возвращать любое значение.
<b>False</b> и <b>nil</b> рассматриваются как false.
Все значения, отличные от <b>nil</b> и <b>false</b>, рассматриваются как true
(в частности, число 0 и пустая строка это тоже true).

<p>
В цикле <b>repeat</b>&ndash;<b>until</b>,
внутренний блок заканчивается после всего условия,
а не на ключевом слове <b>until</b>.
Так, условие может ссылаться на локальные переменные
объявленные внутри цикла.

<p>
Оператор <b>goto</b> передает управление на метку.
По синтаксическим причинам, метки в Lua тоже считаются выражениями:

<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
Метка видна в блоке где объявлена,
за исключением вложенных блоков, где определена метка с таким же именем
и вложенных функций.
Goto может переходить на любую видимую метку, так далеко,
пока не войдет в область видимости локальной переменной.

<p>
Метки и пустые выражения называются <em>пустыми выражениями</em>,
так как они не производят дейтсвий.

<p>
Выражение <b>break</b> завершает исполнение цикла
<b>while</b>, <b>repeat</b> или <b>for</b>,
пропуская оставшиеся команды цикла:

<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b> завершает самый внутренний цикл.

<p>
Выражение <b>return</b> используется для возврата значений из
функции или куска (который является анонимной функцией).

Функции могут возвращать несколько значений,
поэтому синтаксис для выражения <b>return</b> следующий:

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
Выражение <b>return</b> может быть написано только, как последнее в блоке.
Если действительно необходимо иметь <b>return</b>
в середине блока, тогда можно использовать явный внутренний блок,
как идиома <code>do return end</code>,
теперь <b>return</b> это последнее выражение в его (внутреннем) блоке.


<h3>3.3.5 &ndash; <a name="3.3.5">Конструкция For</a></h3>

<p>

Конструкция <b>for</b> имеет две формы:
цифровую и общую.

<p>
Цифровой цикл <b>for</b> повторяет блок кода, пока управляющая переменная
изменяется в арифметической прогрессии.
Он имеет следующий синтаксис:

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>block</em> повторяется для <em>name</em> начиная с первого значения <em>exp</em>,
пока не достигнет значения втрого <em>exp</em>, шагами равными третьему <em>exp</em>.
Более точно, выражение <b>for</b>

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
эквивалентно следующему коду:

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
Имейте ввиду следующее:

<ul>

<li>
Все три управляющие выражения вычисляются только один раз,
перед тем как начнется цикл.
Их результаты должны быть числами.
</li>

<li>
<code><em>var</em></code>, <code><em>limit</em></code> и <code><em>step</em></code> - невидимые переменные.
Имена показаны здесь только для пояснения.
</li>

<li>
Если третье выражение (шаг) отсутствует, тогда используется шаг 1.
</li>

<li>
Для выхода из цикла <b>for</b> вы можете использовать <b>break</b> и <b>goto</b>.
</li>

<li>
Переменная цикла <code>v</code> является локальной для тела цикла.
Если необходимо использовать её значение после цикла,
сохраните его в другой переменной перед выходом из цикла.
</li>

</ul>

<p>
Общий <b>for</b> работает через функции, называемые <em>итераторами</em>.
На каждой итерации, функция-итератор вызывается чтобы выдать новое значение,
остановка происходит, когда новое значение равно <b>nil</b>.
Общий цикл <b>for</b> имеет следующий синтаксис:

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
Выражение <b>for</b>

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
эквивалентно следующему коду:

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
Имейте ввиду следующее:

<ul>

<li>
<code><em>explist</em></code> вычисляется только один раз.
Его результат это функция <em>итератор</em>,
<em>состояние</em> и начальное значение для первой <em>итерируемой переменной</em>.
</li>

<li>
<code><em>f</em></code>, <code><em>s</em></code> и <code><em>var</em></code> - невидимые переменные.
Имена показаны здесь только для пояснения.
</li>

<li>
Для выхода из цикла <b>for</b> вы можете использовать <b>break</b>.
</li>

<li>
Переменная цикла <code><em>var_i</em></code> является локальной для тела цикла.
Если необходимо использовать её значение после цикла,
сохраните его в другой переменной перед выходом из цикла.
</li>

</ul>


<h3>3.3.6 &ndash; <a name="3.3.6">Вызовы функций как выражения</a></h3><p>
Чтобы позволить побочные эффекты,
вызовы функций могут запускаться как выражения:

<pre>
	stat ::= functioncall
</pre><p>
В этом случае все возвращенные значения отбрасываются.
Вызовы функций рассматриваются в <a href="#3.4.10">&sect;3.4.10</a>.


<h3>3.3.7 &ndash; <a name="3.3.7">Локальные определения</a></h3><p>
Локальные переменные могут быть объявлены в любой части блока.
Определение может содержать начальное присваивание (инициализацию):

<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
Если есть начальное присваивание, то оно имеет семантику
схожую с множественным присваиванием (см. <a href="#3.3.3">&sect;3.3.3</a>).
Иначе, все переменные инициализируются значением <b>nil</b>.

<p>
Кусок также является блоком (см. <a href="#3.3.2">&sect;3.3.2</a>), и
следовательно локальные переменные могут быть объявлены в куске
вне всякого явного блока.

<p>
Правила видимости локальных переменных рассматриваются в <a href="#3.5">&sect;3.5</a>.


<h2>3.4 &ndash; <a name="3.4">Выражения</a></h2>

<p>
Базовые выражения в Lua следующие:

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
Числа и литеральные строки рассматриваются в <a href="#3.1">&sect;3.1</a>;
переменные рассматриваются в <a href="#3.2">&sect;3.2</a>;
определения функций рассматриваются в <a href="#3.4.11">&sect;3.4.11</a>;
вызовы функций рассматриваются в <a href="#3.4.10">&sect;3.4.10</a>;
конструкторы таблиц описаны в <a href="#3.4.9">&sect;3.4.9</a>.
Выражения с переменными аргументами, обозначенными тремя точками ('<code>...</code>'),
могут быть использованы только внутри функции с переменным числом аргументов;
они описываются в <a href="#3.4.11">&sect;3.4.11</a>.

<p>
Бинарные операторы, включая арифметические (см. <a href="#3.4.1">&sect;3.4.1</a>),
битовые операторы (см. <a href="#3.4.2">&sect;3.4.2</a>),
операторы сравнения (см. <a href="#3.4.4">&sect;3.4.4</a>),
логические операторы (см. <a href="#3.4.5">&sect;3.4.5</a>),
и оператор конкатенации (см. <a href="#3.4.6">&sect;3.4.6</a>).
Одноместные операторы, включая одноместный минус (см. <a href="#3.4.1">&sect;3.4.1</a>),
одноместный битовый НЕ (см. <a href="#3.4.2">&sect;3.4.2</a>),
одноместный логический <b>not</b> (см. <a href="#3.4.5">&sect;3.4.5</a>),
и одноместный <em>оператор длины</em> (см. <a href="#3.4.7">&sect;3.4.7</a>).

<p>
Функции и выражения с переменным числом аргументов могут
возвращать несколько значений.
Если вызов функции используется как выражение (см. <a href="#3.3.6">&sect;3.3.6</a>),
он возвращает список скорректированный до нуля элементов,
т.е. отброшены все возвращенные значения.
Если выражение используется последним элементом в списке выражений
(или оно только одно), то корректировка не производится
(если выражение не заключено в скобки).

Во всех остальных случаях
Lua корректирует список результатов до одного элемента,
отбрасывая все значения кроме первого,
или добавляя один <b>nil</b>, если значений нет.

<p>
Здесь несколько примеров:

<pre>
     f()                -- корректируется до 0 результатов
     g(f(), x)          -- f() корректируется до 1 результата
     g(x, f())          -- g получает x и все результаты из f()
     a,b,c = f(), x     -- f() корректируется до 1 результата (c получает nil)
     a,b = ...          -- a получает первый множественный параметр, b получает
                        -- второй (a и b могут получить nil, если в множестве параметров нет
                        -- соответствующего параметра)
     
     a,b,c = x, f()     -- f() корректируется до 2 результатов
     a,b,c = f()        -- f() корректируется до 3 результатов
     return f()         -- возвращает все результаты из f()
     return ...         -- возвращает все полученные переменные параметры
     return x,y,f()     -- возвращает x, y и все результаты из f()
     {f()}              -- создает список с результатами из f()
     {...}              -- создает список со всеми переменными параметрами
     {f(), nil}         -- f() корректируется до 1 результата
</pre>

<p>
Любое	 выражение, заключенное в скобки, всегда возвращает только одно значение.
Т.е.,
<code>(f(x,y,z))</code> всегда одно значение,
даже если <code>f</code> возвращает несколько значений.
(Значение <code>(f(x,y,z))</code> это первое из значений возвращенных <code>f</code>
или <b>nil</b>, если <code>f</code> не вернет ни одного значения.)


<h3>3.4.1 &ndash; <a name="3.4.1">Арифметические операторы</a></h3><p>
Lua поддерживает следующие арифметические операторы:

<ul>
<li><b><code>+</code>: </b>сложение</li>
<li><b><code>-</code>: </b>вычитание</li>
<li><b><code>*</code>: </b>умножение</li>
<li><b><code>/</code>: </b>деление</li>
<li><b><code>//</code>: </b>целочисленное деление</li>
<li><b><code>%</code>: </b>модуль</li>
<li><b><code>^</code>: </b>возведение в степень</li>
<li><b><code>-</code>: </b>одноместный минус</li>
</ul>

<p>
За исключением возведения в степень и деления,
арифметические операторы работают следующим образом:
Если оба операнда целые, операция производится над целыми
и результатом является целое.
Иначе, если оба операнда числа или строки,
которые могут быть сконвертированы в числа (см. <a href="#3.4.3">&sect;3.4.3</a>),
они конвертируются в числа с плавающей запятой (float),
операции производятся согласно обычным правилам
арифметики вещественных чисел (обычно стандарт IEEE 754),
и результатом будет число с плавающей запятой.

<p>
Возведение в степень и деление (<code>/</code>)
всегда конвертирует операнды в вещественные числа
и результат вещественное число.
Возведение в степень использует функцию <code>pow</code> из ISO&nbsp;C,
она работает и для не целых экспонент тоже.

<p>
Целочисленное деление (<code>//</code>) - это деление,
которое округляет частное по отношению к минус беспонечности,
т.е. нижнее от деления операндов.

<p>
Модуль определено как остаток от деления,
которое округляет частное по отношению к минус беспонечности (целочисленное деление).

<p>
В случае переполнения целочисленной арифметики,
все операции <em>циклически переходят</em>,
в соответствии с обычными правилами арифметики двоичного дополнения.
(Другими словами,
они возвращают уникальное представимое целое,
которое равно по модулю <em>2<sup>64</sup></em> математическому результату.)


<h3>3.4.2 &ndash; <a name="3.4.2">Битовые операторы</a></h3><p>
Lua поддерживает следующие битовые операторы:

<ul>
<li><b><code>&amp;</code>: </b>битовое И</li>
<li><b><code>&#124;</code>: </b>битовое ИЛИ</li>
<li><b><code>~</code>: </b>битовое ИЛИ НЕ</li>
<li><b><code>&gt;&gt;</code>: </b>правый сдвиг</li>
<li><b><code>&lt;&lt;</code>: </b>левый сдвиг</li>
<li><b><code>~</code>: </b>одноместное битовое НЕ</li>
</ul>

<p>
Все битовые операторы преобразуют свои операнды в целые
(см. <a href="#3.4.3">&sect;3.4.3</a>),
оперируют всеми битами этих целых и результат тоже целое.

<p>
Правый и левый сдвиги заполняют свободные биты нулями.
Отрицательное смещение сдвигает в противоположном направлении;
смещения с абсолютными значениями большими (или равными),
чем число бит в целом, дают результат ноль (все биты сдвинуты наружу).


<h3>3.4.3 &ndash; <a name="3.4.3">Приведения и преобразования</a></h3><p>
Lua производит некоторые автоматические преобразования между типами
и представлениями во время выполнения.
Битовые операторы всегда конвертируют вещественные операнды в целые.
Возведение в степень и деление всегда конвертируют целые операнды в вещественные.
Все остальные арифметические операции, примененные к смешанным числам
(целые и вещественные), преобразуют целые цисла в вещественные;
это называется <em>обычное правило</em>.
C API также конвертирует целые в вещественные и
вещественные в целые, при необходимости.
Более того, конкатенация строк принимает числа, как аргументы
между строками.

<p>
Lua также конвертирует строки в числа, когда ожидается число.

<p>
В преобразовании целого в вещественное,
если целое значение имеет точное представление как вещественное,
это представление и будет результатом.
Иначе, преобразование получает ближайшее большее или
ближайшее меньшее представимое значение.
Этот тип преобразования всегда успешен.

<p>
Преобразование вещественного в целое проверяет,
что вещественное имеет точное представление как целое
(т.е., вещественное имеет целое значение и в диапазоне
представления целых).
Если это так, то это представление будет результатом.
Иначе, преобразование терпит неудачу.

<p>
Преобразование строк в числа идет следующим образом:
Первое, строка преобразуется в целое или вещественное,
следуя синтаксису и правилам лексера Lua.
(Строка может содержать начальные и конечные пробелы и знак.)
Затем, получившееся число (целое или вещественное)
преобразуется в тип (целое или вещественное), требуемый в данном контексте
(т.е., требуемый операцией которая конвертирует принудительно).

<p>
Преобразование чисел в строки использует не определенный читабельный формат.
Для полного контроля над тем, как числа конвертируются в строки,
используйте функцию <code>format</code> из строковой библиотеки
(см. <a href="#pdf-string.format"><code>string.format</code></a>).


<h3>3.4.4 &ndash; <a name="3.4.4">Операторы сравнения</a></h3><p>
Lua поддерживает следующие операторы сравнения:

<ul>
<li><b><code>==</code>: </b>равенство</li>
<li><b><code>~=</code>: </b>неравенство</li>
<li><b><code>&lt;</code>: </b>меньше</li>
<li><b><code>&gt;</code>: </b>больше</li>
<li><b><code>&lt;=</code>: </b>меньше или равно</li>
<li><b><code>&gt;=</code>: </b>больше или равно</li>
</ul><p>
Эти операторы всегда возвращают <b>false</b> или <b>true</b>.

<p>
Равенство (<code>==</code>) сперва сравнивает типы операндов.
Если типы разные, то результат <b>false</b>.
Иначе, сравниваются значения операндов.
Строки сравниваются очевидным способом.
Числа равны, если они обозначают одинаковые математические значения.

<p>
Таблицы, пользовательские данные и потоки сравниваются по ссылке:
два объекта считаются равными только, если это один и тот же объект.
Всегда, когда вы создаете новый объект
(таблицу, пользовательские данные или поток),
этот новый объект отличен от любого существующего объекта.
Замыкания (closure) с одинаковыми ссылками всегда равны.
Замыкания с любыми обнаруживаемыми различиями (разное поведение,
разное определение) всегда различны.

<p>
Используя метаметод "eq", вы можете изменить способ,
которым Lua сравнивает таблицы и пользовательские данные
(см. <a href="#2.4">&sect;2.4</a>).

<p>
Проверка на равенство не конвертирует строки в числа и наоборот.
Так, <code>"0"==0</code> вернет <b>false</b>,
<code>t[0]</code> и <code>t["0"]</code> означают разные элементы в таблице.

<p>
Оператор <code>~=</code> это явное отрицание равенства (<code>==</code>).

<p>
Операторы упорядочения работают следующим образом.
Если оба аргумента числа, то они сравниваются согласно
их математическим значениям.
(независимо от их подтипов).
Иначе, если оба аргумента строки,
то их значения сравниваются согласно текущей локали.
Иначе, Lua пытается вызвать метаметоды "lt" или "le" (см. <a href="#2.4">&sect;2.4</a>).
Сравнение <code>a &gt; b</code> транслируется в <code>b &lt; a</code>
и <code>a &gt;= b</code> транслируется в <code>b &lt;= a</code>.

<p>
Следуя стандарту IEEE 754,
NaN рассматривается как никакой:
не меньший, не больший, не равный ни одному значению (включая себя самого).


<h3>3.4.5 &ndash; <a name="3.4.5">Логические операторы</a></h3><p>
В Lua существуют следующие логические операторы:
<b>and</b> (И), <b>or</b> (ИЛИ) и <b>not</b> (НЕ).
Как и управляющие структуры (см. <a href="#3.3.4">&sect;3.3.4</a>),
все логические операторы считают <b>false</b> и <b>nil</b> как false,
а все остальное как true.

<p>
Оператор отрицания <b>not</b> всегда возвращает <b>false</b> или <b>true</b>.
Оператор конъюнкции <b>and</b> возвращает свой первый аргумент,
если его значение <b>false</b> или <b>nil</b>;
иначе, <b>and</b> возвращает второй аргумент.
Оператор дизъюнкции <b>or</b> возвращает свой первый аргумент,
если его значение отлично от <b>nil</b> и <b>false</b>;
иначе, <b>or</b> возвращает второй аргумент.
Оба <b>and</b> и <b>or</b> используют ленивое вычисление;
т.е., второй операнд вычисляется только если необходимо.
Несколько примеров:

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
(В этом руководстве,
<code>--&gt;</code> означает результат предыдущего выражения.)


<h3>3.4.6 &ndash; <a name="3.4.6">Конкатенация</a></h3><p>
Конкатенация строк в Lua обозначается двумя точками ('<code>..</code>').
Если оба операнда строки или числа, они конвертируются в строки
согласно правилам, описанным в <a href="#3.4.3">&sect;3.4.3</a>.
Иначе, вызывается метаметод <code>__concat</code> (см. <a href="#2.4">&sect;2.4</a>).


<h3>3.4.7 &ndash; <a name="3.4.7">Оператор длины</a></h3>

<p>
Оператор длины обозначается одноместным префиксом <code>#</code>.
Длина строки это число байт в ней
(т.е., обычное значение длины строки, когда каждый символ размером 1 байт).

<p>
Программа может модифицировать поведение оператора длины
для любого значения, кроме строк, используя метаметод <code>__len</code>
(см. <a href="#2.4">&sect;2.4</a>).

<p>
Пока метаметод <code>__len</code> не определен,
длина таблицы <code>t</code> определена только,
если таблица <code>t</code> <em>последовательность</em>,
т.е.,
набор её положительных числовых ключей равен <em>{1..n}</em>
для какого-то положительного целого <em>n</em>.
В этом случае, <em>n</em> это длина.
Имейте ввиду, таблица как

<pre>
     {10, 20, nil, 40}
</pre><p>
это не последовательность, т.к. она имеет ключ <code>4</code>,
но не имеет ключ <code>3</code>.
(Так, там нет <em>n</em>, который в множестве <em>{1..n}</em> равен
набору положительных числовых ключей этой таблицы.)
Тем не менее, эти не числовые ключи не создают помех
с независимой последовательностью в таблице.


<h3>3.4.8 &ndash; <a name="3.4.8">Приоритет</a></h3><p>
Приоритет операторов в Lua представлен далее,
с меньшего к большему приоритету:

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>
Как обычно, чтобы изменить приоритет в выражении, вы можете использовать скобки.
Операторы конкатенации ('<code>..</code>') и возведения в степень ('<code>^</code>')
имеют правую ассоциативность.
Все остальные бинарные операторы имеют левую ассоциативность.


<h3>3.4.9 &ndash; <a name="3.4.9">Конструкторы таблиц</a></h3><p>
Конструкторы таблиц - это выражения, которые создают таблицы.
При каждом запуске конструктора создается новая таблица.
Конструктор может использоваться для создания пустой таблицы
или для создания таблицы с инициализацией некоторых её полей.
Общий синтаксис конструкторов следующий:

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
Каждое поле вида <code>[exp1] = exp2</code> добавляет новый элемент таблицы
с ключем <code>exp1</code> и значением <code>exp2</code>.
Поле вида <code>name = exp</code> эквивалентно записи <code>["name"] = exp</code>.
Поля вида <code>exp</code> эквивалентны <code>[i] = exp</code>,
где <code>i</code> последовательные целые, начинающиеся с 1;
поля в других форматах не влияют на этот счет.
Например,

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
эквивалентно

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- первое exp
       t[2] = "y"         -- второе exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- третье exp
       t[30] = 23
       t[4] = 45          -- четвертое exp
       a = t
     end
</pre>

<p>
Порядок присваиваний в конструкторе не определен.
(Этот порядок важен только для повторяющихся ключей.)

<p>
Если последнее поле в списке имеет вид <code>exp</code>
и выражение это вызов функции или обозначение множества аргументов (...),
то все значения, возвращенные этим выражением, последовательно включаются в список
(см. <a href="#3.4.10">&sect;3.4.10</a>).

<p>
Список полей может иметь опциональный конечный разделитель,
для удобства машинно-сгенерированного кода.


<h3>3.4.10 &ndash; <a name="3.4.10">Вызовы функций</a></h3><p>
Вызов функции в Lua имеет следующий синтаксис:

<pre>
	functioncall ::= prefixexp args
</pre><p>
При вызове функции,
сперва вычисляются prefixexp и args.
Если значение prefixexp имеет тип <em>function</em>,
то вызывается эта функция с данными аргументами.
Иначе, для объекта prefixexp вызывается метаметод "call",
в качестве первого параметра передается значение prefixexp,
затем остальные аргументы вызова.
(см. <a href="#2.4">&sect;2.4</a>).

<p>
Форма

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
может быть использована для вызова "методов".
Вызов <code>v:name(<em>args</em>)</code>
это синтаксическое украшение для <code>v.name(v,<em>args</em>)</code>,
за исключением того, что <code>v</code> вычисляется только один раз.

<p>
Аргументы имеют следующий синтаксис:

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
Все выражения в аргументах вычисляются перед вызовом.
<p>
Вызов вида <code>f{<em>fields</em>}</code> это синтаксическое украшение
для <code>f({<em>fields</em>})</code>;
т.е. в качестве аргумента передается одна новая таблица.
<p>
Вызов вида <code>f'<em>string</em>'</code>
(или <code>f"<em>string</em>"</code> или <code>f[[<em>string</em>]]</code>)
это синтаксическое украшение для <code>f('<em>string</em>')</code>;
т.е. в качестве аргумента передается одна литеральная строка.

<p>
Вызов вида <code>return <em>functioncall</em></code> называется <em>хвостовым вызовом</em> (tail call).
Lua реализует <em>соответствующие хвостовые вызовы</em> (proper tail call)
(или <em>соответствующую хвостовую рекурсию</em>):
в хвостовом вызове,
вызванная функция повторно использует элементы стека вызывающей функции.
Следовательно, не существует лимита на число вложенных хвостовых вызовов,
выполняемых программой.
Тем не менее, хвостовой вызов затирает любую отладочную информацию о вызывающей функции.
Имейте ввиду, что хвостовой вызов происходит только с конкретным синтаксисом,
где <b>return</b> имеет только один вызов функции в качестве аргумента;
при таком синтаксисе вызывающая функция возвращает тоже, что и вызванная функция.
Так, в следующих примерах хвостовой вызов не происходит:

<pre>
     return (f(x))        -- результаты корректируются до 1
     return 2 * f(x)
     return x, f(x)       -- дополнительные результаты
     f(x); return         -- результаты отброшены
     return x or f(x)     -- результаты корректируются до 1
</pre>


<h3>3.4.11 &ndash; <a name="3.4.11">Определения функций</a></h3>

<p>
Синтаксис для определения функции:

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
Следующее синтаксическое украшение упрощает определение функций:

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
Выражение

<pre>
     function f () <em>body</em> end
</pre><p>
транслируется в

<pre>
     f = function () <em>body</em> end
</pre><p>
Выражение

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
транслируется в

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
Выражение

<pre>
     local function f () <em>body</em> end
</pre><p>
транслируется в

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
но, не в

<pre>
     local f = function () <em>body</em> end
</pre><p>
(Это имеет значение, когда тело функции содержит ссылки на <code>f</code>.)

<p>
Определение функции - это исполняемое выражение,
значение которого имеет тип <em>function</em>.
Когда Lua предкомпилирует кусок,
все тела функций в нем прекомпилируются тоже.
Затем, всякий раз, когда Lua запускает определение функции,
функция <em>инстанцируется</em> (или <em>замыкается</em>).
Этот экземпляр функции (или <em>замыкание</em> [closure])
будет финальным значением выражения.

<p>
Параметры действуют как локальные переменные,
инициализированные значениями аргументов:

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
Когда функция вызывается,
список аргументов корректируется до длины списка параметров,
пока функция это не <em>функция с переменным числом аргументов</em> (vararg function);
переменные аргументы указываются тремя точками ('<code>...</code>')
в конце списка параметров.
Функция с переменным числом аргументов не корректирует свой список аргументов;
взамен, она коллекционирует все дополнительные аргументы и передает их в функцию
через <em>vararg-выражение</em>,
которое также обозначается тремя точками.
Значение этого выражения это список всех фактических дополнительных аргументов,
подобно функции с множественными возвращаемыми значениями.
Если vararg-выражение используется внутри другого выражения или
в середине списка выражений,
то его результат корректируется до одного элемента.
Если vararg-выражение используется как последний элемент в списке выражений,
то корректировка не производится
(если последнее выражение не заключено в скобки).

<p>
Например, рассмотрим следующие определения:

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
Мы получим следующее соответствие аргументов параметрам и vararg-выражению:

<pre>
     Вызов            Пааметры
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (пусто)
     g(3, 4)          a=3, b=4,   ... --&gt;  (пусто)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
Результаты возвращаются выражением <b>return</b> (см. <a href="#3.3.4">&sect;3.3.4</a>).
Если управление достигает конца функции без выражения <b>return</b>,
то функция не возвращает результатов.

<p>
Существует системозависимый предел числа значений,
которые может вернуть функция.
Этот предел гарантированно больше 1000.

<p>
Синтаксис <em>двоеточия</em> используется для определения <em>методов</em>,
т.е. функций, которые имеют явный дополнительный параметр <code>self</code>.
Таким образом, выражение

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
это синтаксическое украшение для

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>


<h2>3.5 &ndash; <a name="3.5">Правила видимости</a></h2>

<p>

Lua - язык с лексическими областями видимости.
Область видимости локальной переменной начинается с первого выражения
после её определения и продолжается до последнего не пустого выражения
внутреннего блока, включающего определение.
Рассмотрим следующий пример:

<pre>
     x = 10                -- глобальная переменная
     do                    -- новый блок
       local x = x         -- новый 'x', со значением 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- другой блок
         local x = x+1     -- другой 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (глобальная переменная)
</pre>

<p>
Учтите, что в определении вида <code>local x = x</code>,
новый <code>x</code> пока вне зоны видимости
и, таким образом, второй <code>x</code> ссылается на внешнюю переменную.

<p>
Согласно правилам видимости,
локальные переменные могут быть свободно доступны функциям,
определенным в их зоне видимости.
Локальная переменная, которая используется внутренней функцией,
внутри данной функции называется <em>upvalue</em>
или <em>внешняя локальная переменная</em>.

<p>
Обратите внимание, каждое выполнение выражения <b>local</b>
определяет новую локальную переменную.
Рассмотрим следующий пример:

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
Цикл создает 10 замыканий
(т.е., 10 экземпляров анонимной функции).
Каждое из этих замыканий использует разные переменные <code>y</code>
и общую для всех <code>x</code>.


<h1>4 &ndash; <a name="4">Программный интерфейс (API)</a></h1>

<p>

Этот раздел описывает C&nbsp;API для Lua, т.е.
набор C&nbsp;функций, доступный хостовой программе для взаимодействия с Lua.
Все API функции и связанные типы и константы определены в заголовочном файле
<a name="pdf-lua.h"><code>lua.h</code></a>.


<p>
Каждый раз, когда мы используем термин "функция",
любая возможность в API может быть реализована как макрос.
Везде, где не оговорено обратное,
все такие макросы используют каждый свой аргумент только один раз
(исключая первый аргумент, который всегда является контекстом Lua)
и не генерируют ни каких скрытых побочных эффектов.

<p>
Как и в большинстве C&nbsp;библиотек,
функции Lua API не проверяют свои аргументы на корректность и согласованность.
Тем не менее, вы можете изменить это поведение, скомпилировав Lua
с включенным определением <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a>.


<h2>4.1 &ndash; <a name="4.1">Стек</a></h2>

<p>
Чтобы передавать значения из и в С Lua использует <em>виртуальный стек</em>.
Каждый элемент этого стека представляет Lua значение
(<b>nil</b>, number, string и др.).

<p>
Кажды раз, когда Lua вызывает C, вызванная функция получает новый стек,
который независим от предыдущих стеков и стеков активных в данный момент
C&nbsp;функций.
Этот стек изначально содержит все аргументы для C&nbsp;функции,
туда же C&nbsp;функция ложит свои результаты,
чтобы вернуть вызывающей стороне (см. <a href="#lua_CFunction"><code>lua_CFunction</code></a>).

<p>
Для удобства,
большинство операций запроса в API не следуют строгой стековой дисциплине.
Напротив, они могут ссылаться на любой элемент в стеке, используя его <em>индекс</em>:
Положительный индекс представляет абсолютную позицию в стеке
(начиная с&nbsp;1);
отрицательный индекс представляет смещение относительно вершины стека.
Точнее, если стек имеет <em>n</em> элементов,
индекс&nbsp;1 представляет первый элемент
(т.е., элемент, который был положен на стек первым)
и
индекс&nbsp;<em>n</em> представляет последний элемент;
индекс&nbsp;-1 также представляет последний элемент
(т.е., элемент на вершине стека)
и индекс <em>-n</em> представляет первый элемент.


<h2>4.2 &ndash; <a name="4.2">Размер стека</a></h2>

<p>
Когда вы работаете с Lua API,
вы ответственны за гарантирование согласованности.
В частности,
<em>вы ответственны за контроль над переполнением стека</em>.
Вы можете использовать функцию <a href="#lua_checkstack"><code>lua_checkstack</code></a>
чтобы проверять, что стек имеет достаточно места для новых элементов.

<p>
Каждый раз, когда Lua вызывает C,
он убеждается, что стек имеет место для как минимум
<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> дополнительных слотов.
<code>LUA_MINSTACK</code> определен равным 20,
так обычно вы не должны беспокоиться о размере стека,
пока ваш код не содержит циклы, помещающие элементы в стек.

<p>
Когда вы вызываете Lua функцию без определенного числа результатов
(см. <a href="#lua_call"><code>lua_call</code></a>),
Lua гарантирует, что стек имеет достаточно места для помещения всех результатов,
но не гарантирует любое дополнительное пространство.
Так, перед тем как положить что-либо на стек после вызова функции,
вы должны использовать <a href="#lua_checkstack"><code>lua_checkstack</code></a>.


<h2>4.3 &ndash; <a name="4.3">Правильные и допустимые индексы</a></h2>

<p>
Любая API функция, получающая стековые индексы,
работает только с <em>правильными индексами</em> или <em>допустимыми индексами</em>.


<p>
<em>Правильный индекс</em> - это индекс, который ссылается на позицию,
содержащую модифицируемое Lua значение.
Допустимый диапазон включает стековые индексы между&nbsp;1 и вершиной стека
(<code>1 &le; abs(index) &le; top</code>)

плюс <em>псевдоиндексы</em>,
которые представляют некоторые позиции, доступные для C&nbsp;кода,
но не находящиеся в стеке.
Псевдоиндексы используются для доступа к реестру (см. <a href="#4.5">&sect;4.5</a>)
и к внешним локальным переменным (upvalue) C&nbsp;функции (см. <a href="#4.4">&sect;4.4</a>).

<p>
Функции, не нуждающиеся в специфической изменяемой позиции,
а нуждающиеся только в значении (т.е., функции запросов),
могут быть вызваны с допустимыми индексами.
<em>Допустимым индексом</em> может быть любой правильный индекс,
но это также может быть любой положительный индекс после вершины стека
внутри пространства, выделенного для стека,
т.е., индексы выше размера стека.
(Учтите, что 0 это всегда недопустимый индекс.)
Если не оговорено иное, API функции работают с допустимыми индексами.

<p>
Допустимые индексы служат для избежания дополнительных тестов
вершины стека при запросах.
Например, C&nbsp;функция может запросить свой третий аргумент
без проверки его существования,
т.е., без проверки того, что индекс 3 является правильным.

<p>
Для функций, которые могут быть вызваны с допустимыми индексами,
любой не правильный индекс, трактуется как индекс к значению
виртуального типа <a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>,
которое ведет себя как значение nil.


<h2>4.4 &ndash; <a name="4.4">C замыкания</a></h2>

<p>
Когда C&nbsp;функция создана,
можно ассоциировать с ней несколько значений,
таким образом создав <em>C&nbsp;замыкание</em> (closure)
(см. <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>);
эти значения называются <em>upvalue</em>
и доступны функции во время вызова.

<p>
При каждом вызове C&nbsp;функции,
её upvalue располагаются по специфическим псевдоиндексам.
Псевдоиндексы создаются макросом
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>.
Первое upvalue, ассоциированное с функцией, располагается по индексу
<code>lua_upvalueindex(1)</code>, и так далее.
Любое обращение к <code>lua_upvalueindex(<em>n</em>)</code>,
где <em>n</em> больше количества upvalue текущей функции
(но не больше 256),
создает допустимый, но не правильный индекс.


<h2>4.5 &ndash; <a name="4.5">Реестр</a></h2>

<p>
Lua предоставляет <em>реестр</em>,
предопределенную таблицу, которая доступна C&nbsp;коду
для хранения любых Lua значений.
Таблица рееста всегда расположена по псевдоидексу
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>.
Любая C&nbsp;библиотека может хранить данные в этой таблице,
но она должна заботиться о выборе уникальных ключей,
чтобы избежать коллизий с другими библиотеками.
Обычно, вы должны использовать в качестве ключа строку содержащую имя библиотеки,
или легкие пользовательские данные (light userdata) с адресом C&nbsp;объекта в вашем коде,
или любой Lua объект созданный вашим кодом.
Как и имена переменных, ключи, начинающиеся с подчеркивания со следующими
за ним прописными буквами, зарезервированы для Lua.

<p>
Целочисленные ключи в реестре используются
механизмом ссылок (см. <a href="#luaL_ref"><code>luaL_ref</code></a>)
и некоторыми предопределенными значениями.
Следовательно, целочисленные ключи не должны использоваться для других целей.

<p>
Когда вы создаете новый Lua контекст,
его реестр содержит некоторые предопределенные значения.
Эти предопределенные значения индексируются целочисленными ключами,
определенными как константы в <code>lua.h</code>.
Определены следующие константы:

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: 
</b> По этому индексу в реестре расположен главный поток контекста.
(Главный поток создается при создании контекста.)
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>:
</b> По этому индексу в реестре расположено глобальное окружение.
</li>
</ul>


<h2>4.6 &ndash; <a name="4.6">Обработка ошибок в C</a></h2>

<p>
Внутри, для обработки ошибок Lua использует C <code>longjmp</code>.
(Lua будет использовать исключения, если вы скомпилируете его как C++;
для подробностей ищите <code>LUAI_THROW</code> в исходном коде.)
Когда Lua сталкивается с любой ошибкой
(такой как ошибка выделения памяти, ошибки типов, синтаксические ошибки
и ошибки времени выполнения),
он <em>возбуждает</em> ошибку;
т.е., делает длинный переход (long jump).
<em>Защищенное окружение</em> использует <code>setjmp</code>
для установки точки восстановления;
любая ошибка переходит к самой последней точке восстановления.

<p>
Если ошибка случается за пределами защищенного окружения,
Lua вызывает <em>функцию паники</em> (см. <a href="#lua_atpanic"><code>lua_atpanic</code></a>)
и затем вызывает <code>abort</code>,
завершая хостовое приложение.
Ваша функция паники может избежать завершения приложения,
если не вернет управление
(т.е., сделает длинный переход [long jump] на вашу точку восстановления вне Lua).

<p>
Функция паники запускается как обработчик сообщений (см. <a href="#2.3">&sect;2.3</a>);
в частности, сообщение об ошибке лежит на вершине стека.
Тем не менее, это не гарантирует стековое пространство.
Чтобы положить что-либо на стек,
функция паники должна сперва проверить доступное место (см. <a href="#4.2">&sect;4.2</a>).

<p>
Большинство API функций могут возбуждать ошибки,
например при выделении памяти.
Описание для каждой функции предупреждает,
что она может возбуждать ошибки.

<p>
Внутри C&nbsp;функции вы можете сгенерировать ошибку вызовом <a href="#lua_error"><code>lua_error</code></a>.


<h2>4.7 &ndash; <a name="4.7">Обработка уступок в C</a></h2>

<p>
Внутри, для приостановки сопрограммы Lua использует C <code>longjmp</code>.
Следовательно, если C функция <code>foo</code> вызывает функцию API
и эта API функция уступает
(прямо или опосредованно, вызывая другую функцию, которая уступает),
Lua больше не может вернуться к <code>foo</code>,
потому что <code>longjmp</code> удаляет свой фрейм из C стека.

<p>
Чтобы избежать такой тип проблем,
Lua возбуждает ошибку каждый раз, когда происходит уступка через вызов API,
за исключением трех функций:
<a href="#lua_yieldk"><code>lua_yieldk</code></a>, <a href="#lua_callk"><code>lua_callk</code></a>
и <a href="#lua_pcallk"><code>lua_pcallk</code></a>.
Все эти функции получают <em>функцию продолжения</em>
(как параметр <code>k</code>) чтобы продолжить исполнение после уступки.

<p>
Чтобы рассмотреть продолжения установим некоторую терминологию.
Мы имеем C функцию вызванную из Lua, назовем её <em>оригинальной функцией</em>.
Эта оригинальная функция затем вызывает одну из этих трех API функций,
которые мы будем называть <em>вызываемой функцией</em>,
которая затем уступает текущий поток.
(Это может случиться, когда вызываемая функция это <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
или когда вызываемая функция любая из <a href="#lua_callk"><code>lua_callk</code></a>
или <a href="#lua_pcallk"><code>lua_pcallk</code></a>
и вызванная ими функция уступает.)

<p>
Допустим, выполняющийся поток уступает во время выполнения вызываемой функции.
Затем поток продолжается,
это в конечном счете завершит вызываемую функцию.
Тем не менее,
вызываемая функция не может вернуться в оригинальную,
т.к. её фрейм в C стеке был уничтожен уступкой.
Взамен, Lua вызывает <em>функцию продолжения</em>,
которая передается как аргумент вызываемой функции.
Как подразумевается, продолжающая функция должна
продолжить выполнение задачи оригинальной функции.

<p>
Как иллюстрацию, рассмотрим следующую функцию:

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>
Сейчас мы хотим позволить Lua коду, запущенному через
<a href="#lua_pcall"><code>lua_pcall</code></a>, уступать.
Сначала, перепишем нашу функцию как показано ниже:

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
В этом коде,
новая функция <code>k</code> это <em>функция продолжения</em>
(с типом <a href="#lua_KFunction"><code>lua_KFunction</code></a>),
которая должна делать всю работу, которую оригинальная функция
делала после вызова <a href="#lua_pcall"><code>lua_pcall</code></a>.
Мы должны проинформировать Lua о том, что
если Lua код, запущенный <a href="#lua_pcall"><code>lua_pcall</code></a>,
будет прерван (ошибки или уступка),
то необходимо вызвать <code>k</code>;
переписываем код,
заменяя <a href="#lua_pcall"><code>lua_pcall</code></a> на <a href="#lua_pcallk"><code>lua_pcallk</code></a>:

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
Обратите внимание на внешний явный вызов продолжения:
Lua будет вызывать продолжение только при необходимости,
т.е. в случае ошибок или возобновления после уступки.
Если вызванная функция возвратится нормально, без уступок,
<a href="#lua_pcallk"><code>lua_pcallk</code></a>
(и <a href="#lua_callk"><code>lua_callk</code></a>) также возвратятся нормально.
(Конечно, в этом случае вместо вызова продолжения,
вы можете выполнить эквивалентную работу прямо внутри оригинальной функции.)

<p>
Рядом с Lua состоянием, функция продолжения имеет два других параметра:
конечный статус вызова и контекстное значение (<code>ctx</code>),
которое изначально передается в <a href="#lua_pcallk"><code>lua_pcallk</code></a>.
(Lua не использует это контекстное значение;
только передает его из оригинальной функции в функцию продолжения.)
Для <a href="#lua_pcallk"><code>lua_pcallk</code></a>,
статус это тоже значение, которое будет возвращено функцией <a href="#lua_pcallk"><code>lua_pcallk</code></a>,
за исключением того, что после выполнения уступки это будет <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>,
(взамен <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>).
Для <a href="#lua_yieldk"><code>lua_yieldk</code></a> и <a href="#lua_callk"><code>lua_callk</code></a>,
когда Lua вызывает продолжение,
статус всегда будет равен <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>.
(Для этих двух функций в случае ошибок Lua не вызовет продолжение,
т.к. они не обрабатывают ошибки.)
Аналогично, когда используется <a href="#lua_callk"><code>lua_callk</code></a>,
вы должны вызывать функцию продолжения со статусом <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.
(Для <a href="#lua_yieldk"><code>lua_yieldk</code></a>, нет смысла в прямом
вызове функции продолжения,
т.к. <a href="#lua_yieldk"><code>lua_yieldk</code></a> обычно не возвращается.)

<p>
Lua обрабатывает функцию продолжения так, как будто это оригинальная функция.
Функция продолжения получает тот же Lua стек из оригинальной функции,
в том же состоянии, как если бы вызываемая функция вернулась.
(Например, после <a href="#lua_callk"><code>lua_callk</code></a>
функция и её аргументы удалены из стека и заменены результатами вызова.)
Она также будет иметь те же upvalue.
Результаты, которые она вернет, будут обработаны Lua так,
как будто их вернула оригинальная функция.


<h2>4.8 &ndash; <a name="4.8">Функции и типы</a></h2>

<p>
Здесь представлен список всех функций и типов из C&nbsp;API
в алфавитном порядке.
Каждая функция имеет индикатор вида:
<span class="apii">[-o, +p, <em>x</em>]</span>

<p>
Первое поле, <code>o</code>,
показывает сколько элементов функция снимает со стека.
Второе поле, <code>p</code>,
показывает сколько элементов функция ложит на стек.
(Функции всегда ложат свои результаты после того, как снимут аргументы со стека.)
Поле вида <code>x|y</code> означает, что функция может ложить (или снимать)
<code>x</code> или <code>y</code> элементов, в зависимости от ситуации;
знак вопроса '<code>?</code>' означает, что
по аргументам функции невозможно определить сколько элементов функция ложит/снимает
(т.е. функция может зависеть от того, что лежит в стеке).
Третье поле, <code>x</code>,
показыает может ли функция генерировать ошибки:
'<code>-</code>' означает, что функция никогда не генерирует ошибки;
'<code>e</code>' означает, что функция может генерировать ошибки;
'<code>v</code>' означает, что фунция предназначена для генерации ошибки.


<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
Конвертирует допустимый индекс <code>idx</code>
в эквивалентный абсолютный индекс
(который не зависит от вершины стека).


<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
Тип функции выделения памяти, которая используется состоянием Lua.
Функция выделения памяти должна предоставлять функциональность подобную
функции <code>realloc</code>, но не точно такую же.
Её аргументы
<code>ud</code> - непрозрачный указатель, передаваемый в
<a href="#lua_newstate"><code>lua_newstate</code></a>;
<code>ptr</code> - указатель на блок для выделения/перераспределения/освобождения;
<code>osize</code> - оригинальный размер блока или код, определяющий под что выделяется память;
<code>nsize</code> - новый размер блока.

<p>
Когда <code>ptr</code> не <code>NULL</code>,
<code>osize</code> это размер блока по указателю <code>ptr</code>,
т.е. размер полученный при выделении или перераспределении.

<p>
Когда <code>ptr</code> = <code>NULL</code>,
<code>osize</code> кодирует тип объекта, для которого выделяется память.
<code>osize</code> может быть равен
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a> и
<a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,
когда (и только когда)
Lua создает новый объект данного типа.
Когда <code>osize</code> какое-то другое значение,
Lua выделяет память для чего-то другого.

<p>
Lua предполагает следующее поведение функции выделения памяти:

<p>
Когда <code>nsize</code> = 0,
функция должна действовать как <code>free</code>
и возвращать <code>NULL</code>.

<p>
Когда <code>nsize</code> != 0,
функция должна действовать как <code>realloc</code>.
Функция возвращает <code>NULL</code> только, если не может выполнить запрос.
Lua предполагает, что функция выделения памяти не может выдать ошибку при
<code>osize &gt;= nsize</code>.

<p>
Здесь представлена простая реализация функции выделения памяти.
Она используется во вспомогательной библиотеке функцией <a href="#luaL_newstate"><code>luaL_newstate</code></a>.

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
Учтите, что стандартный&nbsp;C гарантирует, что <code>free(NULL)</code>
не производит действий и
<code>realloc(NULL,size)</code> эквивалентно <code>malloc(size)</code>.
Этот код предполагает, что <code>realloc</code> не вызывает ошибок при
уменьшении блока.
(Хотя стандартный&nbsp;C не предполагает такого поведения,
кажется, это безопасное предположение.)


<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
Выполняет арифметическую или битовую операцию над двумя значениями
(или одним, в случае отрицаний),
находящимися на вершине стека,
значение на вершине является вторым операндом,
удаляет эти значения со стека и ложит результат операции.
Функция следует семантике соответствующего оператора
(т.е., может вызывать метаметоды).

<p>
Значение <code>op</code> должно быть одной из следующих констант:
<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> сложение (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> вычитание (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> умножение (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> деление (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> целочисленное деление (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> модуль (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> возведение в степень (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> математическое отрицание (одноместный <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> битовое отрицание (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> битовое И (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> битовое ИЛИ (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> битовое ИЛИ-НЕ (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> левый сдвиг (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> правый сдвиг (<code>&gt;&gt;</code>)</li>

</ul>


<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
Устанавливает новую функцию паники и возвращает старую (см. <a href="#4.6">&sect;4.6</a>).


<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
Вызывает функцию.

<p>
Для вызова функции вы должны использовать следующий протокол:
первое,  вызываемая функция должна быть помещена в стек;
затем, на стек ложатся аргументы в прямом порядке;
т.е., первый аргумент ложится первым.
Наконец, производится вызов <a href="#lua_call"><code>lua_call</code></a>;
<code>nargs</code> - количество аргументов на стеке.
Когда функция вызывается, все аргументы и функция снимаются со стека.
Результаты ложатся на стек, когда функция возвращается.
Количество результатов корректируется до <code>nresults</code>,
если <code>nresults</code> не равно <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>.
В этом случае, все результаты из функции ложатся на стек.
Lua заботится, чтобы возвращенным значениям хватило места в стеке.
Результаты функции ложатся в стек в прямом порядке
(первый результат ложится первым),
так что после вызова последний результат будет на вершине стека.

<p>
Любая ошибка внутри вызванной функции распространяется вверх
(с <code>longjmp</code>).

<p>
Следующий пример показывает, как хостовая программа может выполнить действия
эквивалентные этому Lua коду:

<pre>
     a = f("how", t.x, 14)
</pre><p>
Это же в &nbsp;C:

<pre>
     lua_getglobal(L, "f");         /* функция для вызова */
     lua_pushliteral(L, "how");     /* 1-й аргумент */
     lua_getglobal(L, "t");         /* таблица для индексирования */
     lua_getfield(L, -1, "x");      /* положить результат t.x (2-й аргумент) */
     lua_remove(L, -2);             /* удаление 't' из стека */
     lua_pushinteger(L, 14);        /* 3-й аргумент */
     lua_call(L, 3, 1);             /* вызов 'f' с 3 аргументами и 1 результатом */
     lua_setglobal(L, "a");         /* установить глобальную 'a' */
</pre><p>
Обратите внимание, что код выше <em>сбалансирован</em>:
после его выполнения стек возвращается в первоначальное состояние.
Это хорошая практика програмирования.


<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Эта функция аналогична <a href="#lua_call"><code>lua_call</code></a>,
но позволяет вызываемой функции уступать (см. <a href="#4.7">&sect;4.7</a>).


<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
Тип для C&nbsp;функций.

<p>
Для правильного взаимодействия с Lua,
C&nbsp;функция должна использовать следующий протокол,
который определяет как передаются параметры и результаты:
C&nbsp;функция получает аргументы из Lua в своём стеке
в прямом порядке (первый аргумент ложится первым).
Так, когда функция стартует,
<code>lua_gettop(L)</code> возвращает количество аргументов, полученных функцией.
Первый аргумент (если существует) находится по индексу 1,
последний аргумент находится по индексу <code>lua_gettop(L)</code>.
Для возврата значений в Lua, C&nbsp;функция просто ложит их на стек
в прямом порядке (первый результат ложится первым)
и возвращает число результатов.
Любое другое значение в стеке ниже результатов будет сброшено Lua.
Как и Lua функция, C&nbsp;функция, вызванная Lua, может возвращать
несколько результатов.

<p>
Например, следующая функция получает переменное количество
числовых аргументов и возвращает их среднее и их сумму:

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);          /* количество аргументов */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);       /* 1-й результат */
       lua_pushnumber(L, sum);         /* 2-й результат */
       return 2;                       /* количество результатов */
     }
</pre>


<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
Проверяет, что стек имеет место для как минимум <code>n</code> дополнительных слотов.
Функция возвращает false, если не может выполнить запрос,
потому что размер стека больше фиксированного максимума
(обычно несколько тысяч элементов) или
поскольку не может выделить память для дополнительных слотов.
Эта функция никогда не уменьшает стек;
если стек уже больше чем новый размер, он остаётся без изменений.


<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
Уничтожает все объекты в Lua состоянии
(вызываются соответствующие метаметоды сборки мусора, если существуют)
и освобождает всю динамическую память, использованную этим состоянием.
На некоторых платформах, вы можете не вызывать эту функцию,
т.к. все ресурсы освобождаются при завершении хостовой программы.
С другой стороны, долго работающие программы, которые создают множество состояний,
такие как демоны или веб-серверы,
вероятно будут нуждаться в закрытии состояний, когда они станут ненужными.


<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
Сравнивает два Lua значения.
Возвращает 1, если значение по индексу <code>index1</code> удовлетворяет <code>op</code>,
когда сравнивается со значением по индексу <code>index2</code>,
следуя семантике соответствующего оператора Lua
(т.е., могут вызываться метаметоды).
Иначе возвращает&nbsp;0.
Также, возвращает&nbsp;0, если любой из индексов не правильный.

<p>
Значение <code>op</code> должно равняться одной из констант:

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> равенство (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> меньше (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> меньше или равно (<code>&lt;=</code>)</li>

</ul>


<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
Производит конкатенацию <code>n</code> значений на вершине стека,
снимает их со стека и оставляет результат на вершине стека.
Если <code>n</code>&nbsp;=&nbsp;1, результат это одно значение на стеке
(т.е., функция ничего не делает);
если <code>n</code> = 0, результат пустая строка.
Конкатенация выполняется следуя обычной семантике Lua
(см. <a href="#3.4.6">&sect;3.4.6</a>).


<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
Копирует элемент по индексу <code>fromidx</code>
в правильный индекс <code>toidx</code>,
заменяя значение на этой позиции.
Значения в других позициях не изменяются.


<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
Создает новую пустую таблицу и ложит её на стек.
Параметр <code>narr</code> - подсказка, сколько элементов в таблице будет как последовательность;
параметр <code>nrec</code> - подсказка, сколько других элементов будет в таблице.
Lua может использовать эти подсказки для предварительного выделения памяти для таблицы.
Это предварительное выделение памяти полезно для производительности, когда вы заранее знаете 
сколько элементов будет в таблице.
Иначе вы можете использовать функцию <a href="#lua_newtable"><code>lua_newtable</code></a>.


<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
Сохраняет функцию как бинарный кусок.
Получает Lua функцию на вершине стека и выдает её скомпилированной,
при повторной загрузке куска, результаты эквивалентны результатам компилируемой функции.
По мере выдачи частей куска, для его записи,
<a href="#lua_dump"><code>lua_dump</code></a>
вызывает функцию <code>writer</code> (см. <a href="#lua_Writer"><code>lua_Writer</code></a>)
с полученной переменной <code>data</code>.

<p>
Если <code>strip</code> = true,
бинарное представление может не включать всю отладочную информацию о функции,
для уменьшения размера.

<p>
Возвращаемое значение: код ошибки, возвращенный при последнем вызове функции writer;
0&nbsp;означает нет ошибок.

<p>
Эта функция не убирает Lua функцию со стека.


<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
Генерирует ошибку Lua,
используя значение на вершине стека, как объект ошибки.
Эта функция производит длинный переход (long jump)
и никогда не возвращается
(см. <a href="#luaL_error"><code>luaL_error</code></a>).


<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
Управляет сборщиком мусора.

<p>
Эта функция производит различные действия,
в зависимости от параметра <code>what</code>:

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
останавливает сборщик мусора.
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
перезапускает сборщик мусора.
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
производит полный цикл сборки мусора.
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
возвращает текущий объем памяти (в килобайтах), используемый Lua.
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
возвращает остаток от деления текущего объема памяти, используемой Lua, в байтах на 1024.
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
производит шаг очистки мусора.
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
устанавливает <code>data</code>, как новое значение для
<em>паузы</em> сборщика (см. <a href="#2.5">&sect;2.5</a>),
и возвращает предыдущее значение паузы.
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
устанавливает <code>data</code>, как новое значение для
<em>множителя шагов</em> сборщика (см. <a href="#2.5">&sect;2.5</a>),
и возвращает предыдущее значение множителя шагов.
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
возвращает логическое значение, которое говорит, что сборщик запущен
(т.е., не остановлен).
</li>

</ul>

<p>
Для более подробного описания опций,
см. <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>.


<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
Возвращает функцию выделения памяти для данного Lua состояния.
Если <code>ud</code> не <code>NULL</code>, Lua записывает в <code>*ud</code>
непрозрачный указатель, полученный когда устанавливалась функция выделения памяти.


<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
Ложит в стек значение <code>t[k]</code>,
где <code>t</code> - значение по индексу index.
Как и в Lua, эта функция может запускать метаметод для события "index"
(см. <a href="#2.4">&sect;2.4</a>).

<p>
Возвращает тип положенного на стек значения.


<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
Возвращает указатель на область "сырой" (raw) памяти, ассоциированную
с данным Lua состоянием.
Приложение может использовать эту область для любых целей;
Lua не использует эту область.

<p>
Каждый новый поток имеет такую область, инициализированную
копией области главного потока.

<p>
По умолчанию, эта область имеет размер пустого указателя [ sizeof(void*) ],
но вы можете перекомпилировать Lua с другим размером для этой области
(см. <code>LUA_EXTRASPACE</code> в <code>luaconf.h</code>).


<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
Ложит в стек значение глобальной переменной <code>name</code>.
Возвращает тип этого значения.


<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Ложит в стек значение <code>t[i]</code>,
где <code>t</code> - значение по индексу index.
Как и в Lua, эта функция может запускать метаметод для события "index"
(см. <a href="#2.4">&sect;2.4</a>).

<p>
Возвращает тип положенного на стек значения.


<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
Если значение по индексу index имеет метатаблицу,
функция ложит эту метатаблицу на стек и возвращает&nbsp;1.
Иначе, функция возвращает&nbsp;0 и ничего не ложит на стек.


<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
Ложит на стек значение <code>t[k]</code>,
где <code>t</code> - значение по индексу index
и <code>k</code> - значение на вершине стека.

<p>
Эта функция снимает ключ со стека
и ложит результирующее значение на его место.
Как и в Lua, эта функция может запускать метаметод для события "index"
(см. <a href="#2.4">&sect;2.4</a>).

<p>
Возвращает тип положенного на стек значения.


<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
Возвращает индекс элемента на вершине стека.
Т.к. индексы начинаются с&nbsp;1,
результат равен количеству элементов в стеке;
в частности, 0&nbsp;означает, что стек пуст.


<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>

<p>
Ложит на стек Lua значение ассоциированное с пользовательскими данными (userdata),
находящимися по индексу index.

<p>
Возвращает тип положенного на стек значения.


<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
Перемещает верхний элемент стека в полученный правильный индекс,
сдвигая вверх элементы выше этого индекса.
Эта функция не может быть использована с псевдоиндексом,
т.к. псевдоиндекс не обозначает актуальной позиции на стеке.


<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
Тип целых в Lua.

<p>
По умолчанию, это тип <code>long long</code>,
(обычно 64-битное целое),
но это может быть изменено в <code>long</code> или <code>int</code>
(обычно 32-битное целое).
(см. <code>LUA_INT_TYPE</code> в <code>luaconf.h</code>.)

<p>
Lua также определяет константы
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a> и
<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>,
с минимальным и максимальным значениями для этого типа.


<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index имеет тип boolean,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это C&nbsp;функция,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это функция (любая C или Lua),
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это целое
(т.е., это число и оно представлено как целое [integer]),
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это легкие пользовательские данные
(light userdata), иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это <b>nil</b>,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
Возвращает 1, если полученный индекс не правильный,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
Возвращает 1, если полученный индекс не правильный или
значение по индексу это <b>nil</b>,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это число или
строка конвертируемая в число,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это строка
или число (которое всегда можно преобразовать в строку),
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это таблица,
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это поток (thread),
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
Возвращает 1, если значение по индексу index это пользовательские данные
(любые полные или легкие), иначе возвращает&nbsp;0.


<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
Возвращает 1, если данная сопрограмма может уступить (yield),
иначе возвращает&nbsp;0.


<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
Тип для контекста функции продолжения.
Он должен быть числовым типом.
Этот тип определен как <code>intptr_t</code>,
когда <code>intptr_t</code> доступен,
так что может содержать и указатели.
Иначе, тип определен как <code>ptrdiff_t</code>.


<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
Тип для функций продолжения (см. <a href="#4.7">&sect;4.7</a>).


<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
Возвращает длину значения по индексу index.
Это эквивалент Lua оператору '<code>#</code>' (см. <a href="#3.4.7">&sect;3.4.7</a>) и
может вызывать метаметод для события "length" (см. <a href="#2.4">&sect;2.4</a>).
Результат ложится на стек.


<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
Загружает Lua кусок без запуска его на исполнение.
Если ошибок нет,
<code>lua_load</code> ложит на стек скомпилированный кусок, как Lua функцию.
Иначе, ложит на стек сообщение об ошибке.

<p>
Возвращаемые значения <code>lua_load</code>:

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> нет ошибок;</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
синтаксическая ошибка при компиляции;</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
ошибка выделения памяти;</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
ошибка при выполнении метаметода <code>__gc</code>.
(Эта ошибка не имеет отношения к загружаемому куску.
Она генерируется сборщиком мусора.)
</li>

</ul>

<p>
Функция <code>lua_load</code> использует пользовательскую функцию <code>reader</code>
для чтения куска (см. <a href="#lua_Reader"><code>lua_Reader</code></a>).
Аргумент <code>data</code> - это непрозрачный указатель, передаваемый функции reader.

<p>
Аргумент <code>chunkname</code> дает куску имя,
которое используется для сообщений об ошибках и в отладочной информации
(см. <a href="#4.9">&sect;4.9</a>).

<p>
<code>lua_load</code> автоматически определяет, когда кусок текст или бинарные данные,
и соответственно загружает его (см. программу <code>luac</code>).
Строка <code>mode</code> работает как и в функции <a href="#pdf-load"><code>load</code></a>,
с добавлением того, что
значение <code>NULL</code> эквивалентно строке "<code>bt</code>".

<p>
<code>lua_load</code> использует стек непосредственно,
поэтому функция reader всегда должна оставлять его неизменным после возвращения.

<p>
Если результирующая функция имеет внешние локальные переменные (upvalue),
её первое upvalue устанавливается в значение глобального окружения,
записанное в реестре по индексу <code>LUA_RIDX_GLOBALS</code> (см. <a href="#4.5">&sect;4.5</a>).
При загрузке главных кусков,
это upvalue будет переменной <code>_ENV</code> (см. <a href="#2.2">&sect;2.2</a>).
Остальные upvalue инициализируются значением <b>nil</b>.


<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
Создает новый поток, выполняющийся в новом независимом состоянии.
Возвращает <code>NULL</code>, если не может создать поток или состояние
(из-за нехватки памяти).
Аргумент <code>f</code> - функция выделения памяти;
Lua выполняет всё выделение памяти для данного состояния через эту функцию.
Второй аргумент, <code>ud</code> - это непрозрачный указатель, который Lua
передает в функцию выделения памяти при каждом вызове.


<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
Создает новую пустую таблицу и ложит её на стек.
Эквивалентно вызову <code>lua_createtable(L, 0, 0)</code>.


<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Создает новый поток, ложит его на стек
и возвращает указатель на <a href="#lua_State"><code>lua_State</code></a>,
который представляет этот новый поток.
Новый поток использует одно глобальное окружение с оригинальным потоком,
но имеет независимый стек исполнения.

<p>
Не существует явной функции для закрытия или уничтожения потока.
Потоки это субъект для сборки мусора, как и любой Lua объект.


<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
Функция выделяет новый блок памяти размером size,
ложит на стек новый объект full userdata (полные пользовательские данные)
с адресом этого блока, и возвращает этот адрес.
Хостовая программа может свободно использовать эту память.


<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
Снимает ключ со стека,
ложит пару ключ-значение из таблицы, находящейся по индексу index
("следующая" пара после данного ключа).
Если в таблице больше нет элементов,
<a href="#lua_next"><code>lua_next</code></a> возвращает 0
(и ничего не ложит на стек).

<p>
Типичный перебор элементов таблицы выглядит так:

<pre>
     /* таблица находится в стеке по индексу 't' */
     lua_pushnil(L);  /* первый ключ */
     while (lua_next(L, t) != 0) {
       /* используем 'ключ' (по индексу -2) и 'значение' (по индексу -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* удалаяем 'значение', сохраняя 'ключ' для следующей итерации */
       lua_pop(L, 1);
     }
</pre>

<p>
Когда производится перебор таблицы,
не вызывайте <a href="#lua_tolstring"><code>lua_tolstring</code></a> прямо на ключе,
пока не убедитесь, что ключ действительно строка.
Помните, что <a href="#lua_tolstring"><code>lua_tolstring</code></a> может изменить
значение на полученном индексе;
это собьет следующий вызов <a href="#lua_next"><code>lua_next</code></a>.

<p>
Смотри функцию <a href="#pdf-next"><code>next</code></a> 
для предостережений о модификации таблицы во время её перебора.


<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
Тип вещественных чисел в Lua.

<p>
По умолчанию, это тип double,
но он может быть изменен в single float или long double
(см. <code>LUA_FLOAT_TYPE</code> в <code>luaconf.h</code>).


<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
Преобразует вещественное Lua в целое Lua.
Этот макрос предполагает, что <code>n</code> имеет целое значение.
Если это значение входит в диапазон целых Lua,
оно конвертируется в целое и назначается в <code>*p</code>.
Макрос возвращает логическое значение, указывающее, что преобразование успешно.
(Учтите, что из-за округлений эта проверка диапазона может быть мудрёной,
чтобы сделать её корректно без этого макроса.)

<p>
Этот макрос может вычислять свои аргументы несколько раз.


<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
Вызывает функцию в защищенном режиме.

<p>
Оба <code>nargs</code> и <code>nresults</code> имеют тоже значение,
что и в <a href="#lua_call"><code>lua_call</code></a>.
Если в течение вызова нет ошибок,
<a href="#lua_pcall"><code>lua_pcall</code></a> действует точно как <a href="#lua_call"><code>lua_call</code></a>.
Тем не менее, в случае любых ошибок,
<a href="#lua_pcall"><code>lua_pcall</code></a> перехватывает их,
ложит одно значение на стек (собщение об ошибке)
и возвращает код ошибки.
Как и <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> всегда удаляет функцию и её аргументы со стека.

<p>
Если <code>msgh</code> = 0,
сообщение об ошибке, возвращенное на стек, это оригинальное сообщение об ошибке.
Иначе, <code>msgh</code> - это стековый индекс <em>обработчика ошибок</em>.
(Этот индекс не может быть псевдоиндексом.)
В случае ошибок выполнения, эта функция будет вызвана с сообщением об ошибке
и значение, которое она вернет, будет возвращено на стеке функцией
<a href="#lua_pcall"><code>lua_pcall</code></a>.

<p>
Обычно обработчик ошибок используется чтобы добавить больше отладочной информации
в сообщение об ошибке, такой как трассировка стека.
Эта информация не может быть получена после возврата из <a href="#lua_pcall"><code>lua_pcall</code></a>,
поскольку стек будет ракручен.

<p>
Функция <a href="#lua_pcall"><code>lua_pcall</code></a> возвращает
одну из следующих констант (определенны в <code>lua.h</code>):

<ul>
<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>успех.</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>ошибка выполнения.</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
ошибка выделения памяти. Для таких ошибок Lua не вызывает обработчик ошибок.</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
ошибка при выполнении обработчика ошибок.</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
ошибка при выполнении метаметода <code>__gc</code>.
(Эта ошибка обычно не имеет отношения к вызываемой функции.)</li>
</ul>


<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Функция аналогична <a href="#lua_pcall"><code>lua_pcall</code></a>,
но позволяет вызванной функции уступать (см. <a href="#4.7">&sect;4.7</a>).


<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Снимает <code>n</code> элементов со стека.


<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Ложит на стек логическое значение (boolean) равное <code>b</code>.


<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Ложит на стек новое C&nbsp;замыкание.

<p>
Когда C&nbsp;функция создана,
можно ассоциировать с ней несколько значений,
таким образом создав <em>C&nbsp;замыкание</em> (closure)
(см. <a href="#4.4">&sect;4.4</a>);
эти значения доступны функции во время вызова.
Чтобы ассоциировать эти значениея с C&nbsp;функцией,
сначала эти значения нужно положить на стек (первое значение ложится первым).
Затем вызвать <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
для создания C&nbsp;функции на стеке, с аргументом <code>n</code>,
сообщающим сколько значений будет ассоциировано с функцией.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
снимает эти значения со стека.

<p>
Максимальное значение для <code>n</code> это 255.

<p>
Когда <code>n</code> = 0,
эта функция создает <em>лёгкую C функцию</em>,
которая является лишь указателем на C&nbsp;функцию.
В этом случае, она никогда не вызывает ошибку памяти.


<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Ложит C&nbsp;функцию на стек.
Эта функция принимает указатель на C функцию
и ложит в стек Lua значение типа <code>function</code>,
которое при вызове запускает соответствующую C&nbsp;функцию.

<p>
Любая функция, чтобы быть работоспособной в Lua,
должна следовать корректному протоколу приема параметров и возврата результатов
(см. <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Ложит на стек форматированную строку и возвращает указатель на эту строку.
Функция подобна ISO&nbsp;C функции <code>sprintf</code>,
но имеет несколько важных отличий:
<ul>

<li>
Вы не выделяете место для результата:
результат Lua строка и Lua заботится о выделении памяти
(и её освобождении, через сборку мусора).
</li>

<li>
Спецификаторы преобразований ограничены.
Здесь нет флагов, ширины или точности.
Спецификаторы могут быть только следующими:
'<code>%%</code>' (вставляет символ '<code>%</code>'),
'<code>%s</code>' (вставляет строку завершаемую нулем, без ограничений по размеру),
'<code>%f</code>' (вставляет <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%I</code>' (вставляет <a href="#lua_Integer"><code>lua_Integer</code></a>),
'<code>%p</code>' (вставляет указатель как шестнадцатиричное число),
'<code>%d</code>' (вставляет <code>int</code>),
'<code>%c</code>' (вставляет <code>int</code> как однобайтовый символ),
'<code>%U</code>' (вставляет <code>long int</code> как байтовую последовательность UTF-8).
</li>

</ul>


<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
Ложит глобальное окружение в стек.


<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Ложит на стек целое равное <code>n</code>.


<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Ложит на стек легкие пользовательские данные (light userdata).

<p>
Пользовательские данные представляют C&nbsp;значения в Lua.
<em>Легкие пользовательские данные</em> предсталяют указатель, <code>void*</code>.
Это значение (как число):
вы не создаете его, оно не имеет индивидуальной метатаблицы,
и не уничтожается сборщиком (т.к. никогда не создаётся).
Легкие пользовательские данные равны "любым" легким пользовательским данным
с тем же C&nbsp;адресом.


<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
Этот макрос аналогичен <a href="#lua_pushstring"><code>lua_pushstring</code></a>,
но должен использоваться только, когда <code>s</code> это литеральная строка.


<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Ложит на стек строку, указанную <code>s</code>, размером <code>len</code>.
Lua создает (или использует снова) внутреннюю копию данной строки,
так что после завершения функции
память по адресу <code>s</code> может быть освобождена или использована снова.
Строка может содержать любые бинарные данные, в том числе встроенные нули.

<p>
Возвращает указатель на внутреннюю копию строки.


<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
Ложит на стек значение nil.


<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Ложит на стек вещественное число равное <code>n</code>.


<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Ложит на стек завершаемую нулем строку, указанную <code>s</code>.
Lua создает (или использует снова) внутреннюю копию данной строки,
так что после завершения функции
память по адресу <code>s</code> может быть освобождена или использована снова.

<p>
Возвращает указатель на внутреннюю копию строки.

<p>
Если <code>s</code> = <code>NULL</code>, ложит <b>nil</b> и возвращает <code>NULL</code>.


<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
Ложит на стек поток, представленный Lua состоянием <code>L</code>.
Возвращает 1, если поток является главным потоком состояния.


<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Ложит на стек копию элемента по индексу index.


<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Аналогично <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, 
за исключением того, что фунцкция получает <code>va_list</code>
вместо переменного числа аргументов.


<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Возвращает 1, если два значения по индексам <code>index1</code> и <code>index2</code>
примитивно равны (т.е. без вызова метаметодов).
Иначе возвращает&nbsp;0.
Также возвращает&nbsp;0, если любой из индексов не правильный.


<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
Аналогично <a href="#lua_gettable"><code>lua_gettable</code></a>,
но производит "сырой" доступ (т.е. без вызова метаметодов).


<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Ложит на стек значение <code>t[n]</code>,
где <code>t</code> - таблица по индексу index.
Доступ "сырой", т.е. без вызова метаметодов.

<p>
Возвращает тип положенного на стек значения.


<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
Ложит на стек значение <code>t[k]</code>,
где <code>t</code> - таблица по индексу index,
<code>k</code> - указатель <code>p</code>, представленный как лёгкие пользовательские данные.
Доступ "сырой", т.е. без вызова метаметодов.

<p>
Возвращает тип положенного на стек значения.


<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
Возвращет сырую "длину" значения по индексу index:
для строк это длина строки;
для таблиц это результат оператора длины ('<code>#</code>') без метаметодов;
для пользовательских данных это размер выделенного блока памяти;
для остальных значений это &nbsp;0.


<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Аналогично <a href="#lua_settable"><code>lua_settable</code></a>,
но производит "сырое" присваивание (т.е. без вызова метаметодов).


<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Действие аналогично <code>t[i] = v</code>,
где <code>t</code> - таблица по индексу index,
<code>v</code> - значение на вершине стека.

<p>
Эта функция снимает значение со стека.
Присваивание "сырое", т.е. без вызова метаметодов.


<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
Действие аналогично <code>t[p] = v</code>,
где <code>t</code> - таблица по индексу index,
<code>p</code> - кодируется как легкие пользовательские данные,
<code>v</code> - значение на вершине стека.

<p>
Эта функция снимает значение со стека.
Присваивание "сырое", т.е. без вызова метаметодов.


<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
Функция reader использется в <a href="#lua_load"><code>lua_load</code></a>.
Каждый раз, когда требуется следующая часть куска,
<a href="#lua_load"><code>lua_load</code></a> вызывает функцию reader,
передавая ей свой параметр <code>data</code>.
Функция reader должна возвращать указатель на блок памяти
с новой частью куска и устанавливать <code>size</code> равным размеру блока.
Блок должен существовать, пока функция reader не будет вызвана снова.
Для сигнала о конце куска,
функция должна вернуть <code>NULL</code> или установить <code>size</code> равным 0.
Функция reader может возвращать части любого размера больше нуля.


<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
Устанавливает C функцию <code>f</code> в качестве нового значения
глобальной переменной <code>name</code>.
Функция определена как макрос:

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>


<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Удаляет элемент по данному правильному индексу,
сдвигая вниз элементы выше этого индекса, чтобы заполнить промежуток.
Эта функция не может быть вызвана с псевдоиндексом,
т.к. псевдоиндекс не является действительной позицией в стеке.


<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Перемещяет элемент с вершины стека в позицию по правильному индексу index
без сдвига элементов (следовательно, заменяя значение по данному индексу)
и затем снимает вехний элемент со стека.


<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs);</pre>

<p>
Запускает и продолжает сопрограмму в данном потоке <code>L</code>.

<p>
Для запуска подпрограммы,
вы ложите в стек потока главную функцию и её аргументы;
затем вызываете <a href="#lua_resume"><code>lua_resume</code></a>,
<code>nargs</code> - количество аргументов.
Этот вызов возвращается, когда сопрограмма приостанавливается или завершается.
Когда функция возвращается, стек содержит все значения, переданные в
<a href="#lua_yield"><code>lua_yield</code></a>,
или все значения, возвращенные телом функции.
<a href="#lua_resume"><code>lua_resume</code></a> возвращает
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> - если сопрограмма уступила,
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> - если сопрограмма завершила свое исполнение
без ошибок,
или код ошибки в случае ошибок (см. <a href="#lua_pcall"><code>lua_pcall</code></a>).

<p>
В случае ошибок, стек не раскручивается, так вы можете использовать отладочные API на нём.
Сообщение об ошибке находится на вершине стека.

<p>
Чтобы продолжить сопрограмму,
вы удаляете все результаты из последнего <a href="#lua_yield"><code>lua_yield</code></a>,
ложите в её стек только значения, передаваемые в качестве результатов из <code>yield</code>,
и затем вызываете <a href="#lua_resume"><code>lua_resume</code></a>.

<p>
Параметр <code>from</code> представляет сопрограмму, которая продолжает <code>L</code>.
Если такой сопрограммы нет, этот параметр может быть равен <code>NULL</code>.


<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
Вращает элементы стека между правильным индексом <code>idx</code>
и вершиной стека.
Элементы вращаются на <code>n</code> позиций по направлению к вершине стека,
для позитивного <code>n</code>;
или <code>-n</code> позиций в направлении дна стека,
для отрицательного <code>n</code>.
Абсолютное значение <code>n</code> должно быть не больше чем размер вырезки для вращения.
Эта функция не может быть вызвана с псевдоиндексом,
т.к. псевдоиндекс не является действительной позицией в стеке.


<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Заменяет функцию выделения памяти данного состояния на функцию <code>f</code>
с пользовательскими данными <code>ud</code>.


<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Действие аналогично <code>t[k] = v</code>,
где <code>t</code> - таблица по индексу index,
<code>v</code> - значение на вершине стека.

<p>
Эта функция снимает значение со стека.
Как и в Lua, эта функция может запускать метаметод для события "newindex"
(см. <a href="#2.4">&sect;2.4</a>).


<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Снимает значение со стека и 
устанавливает его в качестве нового значения глобальной переменной <code>name</code>.


<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Действие аналогично <code>t[n] = v</code>,
где <code>t</code> - значение по индексу index,
<code>v</code> - значение на вершине стека.

<p>
Эта функция снимает значение со стека.
Как и в Lua, эта функция может запускать метаметод для события "newindex"
(см. <a href="#2.4">&sect;2.4</a>).


<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
Снимает таблицу со стека и устанавливает её в качестве новой метатаблицы
для значения по индексу index.


<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Действие аналогично <code>t[k] = v</code>,
где <code>t</code> - значение по индексу index,
<code>v</code> - значение на вершине стека,
<code>k</code> - значение следующее за верхним.

<p>
Эта функция снимает со стека ключ и значение.
Как и в Lua, эта функция может запускать метаметод для события "newindex"
(см. <a href="#2.4">&sect;2.4</a>).


<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Принимает любой индекс или&nbsp;0,
и устанавливает вершину стека равной этому индексу.
Если новая вершина больше предыдущей,
новые элементы заполняются значением <b>nil</b>.
Если <code>index</code> =&nbsp;0, то все элементы стека удаляются.


<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
Снимает значение со стека и устанавливает его в качестве нового значения,
ассоциированного с пользовальскими данными (userdata) по индексу index.


<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
Непрозрачная структура, которая указывает на поток и косвенно
(через поток) на целое состояние интерпретатора Lua.
Библиотека Lua полностью повторно входимая:
она не имеет глобальных переменных.
Вся информация о состоянии доступна через эту структуру.

<p>
Указатель на эту структуру должен передаваться, как первый аргумент,
в каждую функцию в библиотеке, за исключением <a href="#lua_newstate"><code>lua_newstate</code></a>,
которая создает Lua состояние.


<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
Возвращает состояние потока <code>L</code>.

<p>
Статус может быть 0 (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>) - для нормального потока,
код ошибки - если поток завершил выполнение
<a href="#lua_resume"><code>lua_resume</code></a> с ошибкой,
или <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> - если поток приостановлен.

<p>
Вы можете вызывать функции только в потоках со статусом <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.
Вы можете продолжать потоки со статусом <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
(для запуска новой сопрограммы) или <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
(для продолжения сопрограммы).


<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
Преобразует завершаемую нулем строку <code>s</code> в число,
ложит это число на стек
и возвращает общий размер строки,
т.е. её длину + 1.
Результатом преобразования может быть целое или вещественное число,
в соответствии с лексическими соглашениями Lua (см. <a href="#3.1">&sect;3.1</a>).
Строка может иметь начальные и конечные пробелы и знак.
Если строка не правильное число, функция возвращает 0 и ничего не ложит на стек.
(Имейте ввиду, что результат может быть использован как логическое значение,
если преобразование успешно, то результат true.)


<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Преобразует Lua значение по индексу index в C&nbsp;boolean (0&nbsp;или&nbsp;1).
Как и все проверки в Lua, <a href="#lua_toboolean"><code>lua_toboolean</code></a>
возвращает true для любого Lua значения отличного от <b>false</b> и <b>nil</b>;
иначе, возвращает false.
(Если вы хотите принимать только значения типа boolean,
используйте <a href="#lua_isboolean"><code>lua_isboolean</code></a>
для проверки.)


<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Преобразует Lua значение по индексу index в C&nbsp;функцию.
Это значение должно быть C&nbsp;функцией;
иначе, возвращает <code>NULL</code>.


<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
Эквивалент <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> с <code>isnum</code> = <code>NULL</code>.


<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
Преобразует Lua значение по индексу index в целое со знаком
типа <a href="#lua_Integer"><code>lua_Integer</code></a>.
Lua значение должно быть целым, или числом или строкой, преобразуемой в целое
(см. <a href="#3.4.3">&sect;3.4.3</a>);
иначе, <code>lua_tointegerx</code> возвращает&nbsp;0.

<p>
Если <code>isnum</code> != <code>NULL</code>,
он указывает на логическое значение, которое показывает успешность операции.


<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Преобразует Lua значение по индексу index в C&nbsp;строку.
Если <code>len</code> != <code>NULL</code>,
она также устанавливает <code>*len</code> равным длине строки.
Lua значение должно быть строкой или числом;
иначе, функция возвращает <code>NULL</code>.
Если значение число, то <code>lua_tolstring</code> также
<em>изменяет действительное значение в стеке в строку</em>.
(Это изменение сбивает <a href="#lua_next"><code>lua_next</code></a>,
когда <code>lua_tolstring</code> применяется к ключам при переборе таблицы.)

<p>
<code>lua_tolstring</code> возвращает полностью выровненный указатель
на строку внутри Lua состояния.
Эта строка всегда имеет завершающий ноль ('<code>\0</code>')
после последнего символа (как в&nbsp;C),
но может содержать другие нули в своем теле.

<p>
Т.к. в Lua есть сборка мусора,
нет гарантии, что указатель, возвращенный <code>lua_tolstring</code>,
будет действителен после удаления соответствующего Lua значения из стека.


<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Эквивалент <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> с <code>isnum</code> = <code>NULL</code>.


<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
Преобразует Lua значение по индексу index в C&nbsp;тип <a href="#lua_Number"><code>lua_Number</code></a>
(см. <a href="#lua_Number"><code>lua_Number</code></a>).
Lua значение должно быть числом или строкой, преобразуемой в число
(см. <a href="#3.4.3">&sect;3.4.3</a>);
иначе, <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> возвращает&nbsp;0.

<p>
Если <code>isnum</code> != <code>NULL</code>,
он указывает на логическое значение, которое показывает успешность операции.


<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Преобразует Lua значение по индексу index в пустой C&nbsp;указатель (<code>void*</code>).
Значение может быть пользовательскими данными, таблицей, потоком или функцией;
иначе, <code>lua_topointer</code> возвращает <code>NULL</code>.
Разные объекты дадут разные указатели.
Не существует способа сконвертировать указатель обратно в оригинальное значение.

<p>
Обычно эта функция используется для хеширования и отладочной информации.


<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Эквивалент <a href="#lua_tolstring"><code>lua_tolstring</code></a> с <code>len</code> = <code>NULL</code>.


<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Преобразует Lua значение по индексу index в Lua поток
(представленный как <code>lua_State*</code>).
Это значение должно быть потоком;
иначе, функция возвращает <code>NULL</code>.


<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
Если значение по индексу index это полные пользовательские данные,
возвращает адрес их блока.
Если значение это легкие пользовательские данные,
возвращает их указатель.
Иначе, возвращает <code>NULL</code>.


<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
Возвращает тип значения по правильному индексу index,
или <code>LUA_TNONE</code> для не правильного (но допустимого) индекса.
Типы, возвращаемые <a href="#lua_type"><code>lua_type</code></a>,
кодируются следующими константами (определены в <code>lua.h</code>):
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a> (0),
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>
и
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>.


<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
Возвращает имя типа, кодированного значением <code>tp</code>,
которое должно быть одним из возвращаемых <a href="#lua_type"><code>lua_type</code></a>.


<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
Беззнаковая версия <a href="#lua_Integer"><code>lua_Integer</code></a>.


<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
Возвращает псевдоиндекс, который представляет <code>i</code>-е upvalue
запущенной функции (см. <a href="#4.4">&sect;4.4</a>).


<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
Возвращает адрес номера версии, хранящейся в ядре Lua.
Когда вызвана с правильным <a href="#lua_State"><code>lua_State</code></a>,
возвращает адрес версии, использованной для создания этого состояния.
Когда вызвана с <code>NULL</code>,
возвращает адрес версии выполнившей вызов.


<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
Тип функции writer, используемой в <a href="#lua_dump"><code>lua_dump</code></a>.
Каждый раз, когда производится очередная часть куска,
<a href="#lua_dump"><code>lua_dump</code></a> вызывает функцию writer,
передавая ей буфер для записи (<code>p</code>),
его размер (<code>sz</code>)
и параметр <code>data</code>, переданный в <a href="#lua_dump"><code>lua_dump</code></a>.

<p>
Функция writer возвращает код ошибки;
0&nbsp;означает нет ошибок;
любое другое значение означает ошибку и останавливает <a href="#lua_dump"><code>lua_dump</code></a>
от последующих вызовов writer.


<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Обмен значениями между разными потоками одного состояния.

<p>
Эта функция снимает со стека <code>from</code> <code>n</code> значений
и ложит их в стек <code>to</code>.


<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
Функция аналогична <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
но она не имеет продолжения (см. <a href="#4.7">&sect;4.7</a>).
Следовательно, когда поток продолжается, он продолжает функцию, 
которая вызвала <code>lua_yield</code>.


<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Устапает сопрограмму (поток).

<p>
Когда C&nbsp;функция вызывает <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
вызывающая сопрограмма приостанавливает свое исполнение,
и вызов <a href="#lua_resume"><code>lua_resume</code></a>,
который запустил эту сопрограмму, возвращается.
Параметр <code>nresults</code> - это количество значений в стеке,
которые будут переданы как результаты в <a href="#lua_resume"><code>lua_resume</code></a>.

<p>
Когда сопрограмма снова возобновится,
Lua вызывает переданную функцию продолжения <code>k</code>,
для продолжения выполнения C функции, которая уступила (см. <a href="#4.7">&sect;4.7</a>).
Эта функция продолжения получает тот же стек из предыдущей функции,
но <code>n</code> результатов будут удалены и заменены аргументами,
переданными в <a href="#lua_resume"><code>lua_resume</code></a>.
Кроме того, функция продолжения получает значение <code>ctx</code>,
переданное в <a href="#lua_yieldk"><code>lua_yieldk</code></a>.

<p>
Обычно эта функция не возвращается;
когда сопрограмма в конечном счете возобновляется,
она выполняет фукнцию продолжения.
Тем не менее, есть один специальный случай,
который случается когда функция вызвана из построчного перехватчика
(см. <a href="#4.9">&sect;4.9</a>).
В этом случает, <code>lua_yieldk</code> должна быть вызвана без продолжения
(вероятно в форме <a href="#lua_yield"><code>lua_yield</code></a>),
и перехватчик должен вернуться непосредственно после вызова.
Lua уступит и, когда сопрограмма вновь возобновится,
она продолжит нормальное исполнение (Lua) функции, которая инициировала перехват.

<p>
Эта функция может вызывать ошибку, если вызвана из потока
с незаконченным C вызовом без функции продолжения,
или если вызвана из потока, который не запущен внутри сопрограммы
(т.е., главный поток).


<h2>4.9 &ndash; <a name="4.9">Отладочный интерфейс</a></h2>

<p>
Lua не имеет встроенных отладочных средств.
Взамен, он предлагает специальный интерфейс функций и
<em>перехватчиков</em> (hook).
Этот интерфейс позволяет строить различные типы отладчиков, профилировщиков
и других инструментов, нуждающихся во "внутренней информации" интерпретатора.


<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) количество upvalue */
  unsigned char nparams;      /* (u) количество параметров */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
Структура, используемая для хранения различных частей информации о функции или
о записи активации.
<a href="#lua_getstack"><code>lua_getstack</code></a> заполняет только приватную часть
этой структуры, для последующего использования.
Для заполнения остальных полей <a href="#lua_Debug"><code>lua_Debug</code></a>
полезной информацией, вызовите <a href="#lua_getinfo"><code>lua_getinfo</code></a>.

<p>
Поля <a href="#lua_Debug"><code>lua_Debug</code></a> имеют следующие значения:

<ul>

<li><b><code>source</code>: </b>
имя куска, который создал функцию.
Если <code>source</code> начинается с '<code>@</code>',
это означает, что функция была определена в файле,
где имя файла следует за символом '<code>@</code>'.
Если <code>source</code> начинается с '<code>=</code>',
остаток его содержимого описывает источник в определяемой пользователем форме.
Иначе, функция была определена в строке, где <code>source</code> - эта строка.
</li>

<li><b><code>short_src</code>: </b>
"выводимая" (printable) версия <code>source</code>,
для использования в сообщениях об ошибках.
</li>

<li><b><code>linedefined</code>: </b>
номер строки, где начинается определение функции.
</li>

<li><b><code>lastlinedefined</code>: </b>
номер строки, где заканчивается определение функции.
</li>

<li><b><code>what</code>: </b>
строка <code>"Lua"</code> - если функция это Lua функция,
<code>"C"</code> - если это C&nbsp;функция,
<code>"main"</code> - если это главная часть куска.
</li>

<li><b><code>currentline</code>: </b>
текущая строка, где полученная функция исполняется.
Когда информация о строках не доступна,
<code>currentline</code> устанавливается равным -1.
</li>

<li><b><code>name</code>: </b>
разумное имя полученной функции.
Т.к. функции в Lua это первоклассные значения,
они не имеют фиксированных имен:
некоторые функции могут быть значениями множества глобальных переменных,
тогда как другие могут храниться только в полях таблицы.
Чтобы найти подходящее имя <code>lua_getinfo</code> проверяет как функция была вызвана.
Если она не может найти имя, то <code>name</code> устанавливается равным <code>NULL</code>.
</li>

<li><b><code>namewhat</code>: </b>
поясняет поле <code>name</code>.
Значение <code>namewhat</code> может быть
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code> или <code>""</code> (пустая строка),
в соответствии с тем как была вызвана функция.
(Lua использует пустую строку, когда не может применить ни какую другую опцию.)
</li>

<li><b><code>istailcall</code>: </b>
истина, если этот вызов функции хвостовой (tail call).
В этом случае, вызывающий этого уровня не на стеке.
</li>

<li><b><code>nups</code>: </b>
количество upvalue у функции.
</li>

<li><b><code>nparams</code>: </b>
количество фиксированных параметров у функции
(всегда 0&nbsp;для C&nbsp;функций).
</li>

<li><b><code>isvararg</code>: </b>
истина, если функция имеет переменное число аргументов
(всегда истина для C&nbsp;функций).
</li>

</ul>


<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Возвращает текущую функцию перехватчик.


<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Возвращает количество перехватчиков.


<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Возвращает текущую маску перехватов.


<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Предоставляет информацию о специфической функции или о вызове функции.

<p>
Для получения информации о вызове функции,
параметр <code>ar</code> должен быть правильной записью активации, которая
заполняется вызовом <a href="#lua_getstack"><code>lua_getstack</code></a> или
передается как аргумент в перехватчик (см. <a href="#lua_Hook"><code>lua_Hook</code></a>).

<p>
Для получения информации о функции, нужно положить её в стек и 
начать строку <code>what</code> символом '<code>&gt;</code>'.
(В этом случае, <code>lua_getinfo</code> снимет функцию с вершины стека.)
Например, чтобы узнать в которой строке определена функция <code>f</code>,
вы можете написать следующий код:

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* получить глобальную 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Каждый символ в строке <code>what</code>
выбирает определенные поля в структуре <code>ar</code> для заполнения или
значение, передаваемое через стек:

<ul>

<li><b>'<code>n</code>': </b> заполняет поля <code>name</code> и <code>namewhat</code>;
</li>

<li><b>'<code>S</code>': </b>
заполняет поля <code>source</code>, <code>short_src</code>,
<code>linedefined</code>, <code>lastlinedefined</code> и <code>what</code>;
</li>

<li><b>'<code>l</code>': </b> заполняет поле <code>currentline</code>;
</li>

<li><b>'<code>t</code>': </b> заполняет поле <code>istailcall</code>;
</li>

<li><b>'<code>u</code>': </b> заполняет поля
<code>nups</code>, <code>nparams</code> и <code>isvararg</code>;
</li>

<li><b>'<code>f</code>': </b>
ложит в стек функцию, которая запущена на данном уровне;
</li>

<li><b>'<code>L</code>': </b>
ложит в стек таблицу, индексы которой - это номера значимых строк функции.
(<em>Значимая строка</em> - это строка с некоторым кодом,
т.е. строка, где можно поставить точку останова [break point].
Не значащие строки - это пустые строки и комментарии.)

<p>
Если эта опция получена вместе с опцией '<code>f</code>',
таблица ложится в стек после функции.
</li>

</ul>

<p>
Эта функция возвращает 0 при ошибке
(например, при неправильной опции в строке <code>what</code>).


<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Предоставляет информацию о локальной переменной данной записи активации
или функции.

<p>
В первом случае,
параметр <code>ar</code> должен быть правильной записью активации, которая заполнена
предыдущим вызовом <a href="#lua_getstack"><code>lua_getstack</code></a> или
передана как аргумент перехватчику (см. <a href="#lua_Hook"><code>lua_Hook</code></a>).
Индекс <code>n</code> выбирает локальную переменную для проверки;
см. <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>
для подробностей о индексах и именах переменных.

<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> ложит в стек
значение переменной и возвращает её имя.

<p>
Во втором случае, <code>ar</code> должен быть <code>NULL</code>,
и функция для проверки должна находиться на вершине стека.
В этом случае, видны только параметры Lua функций
(т.к. здесь нет информации о том, какие переменные активны)
и значения в стек не ложатся.

<p>
Возвращает <code>NULL</code> (и ничего не ложит на стек),
когда индекс больше чем количество активных локальных переменных.


<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Предоставляет информацию о исполняемом (runtime) стеке интерпретатора.

<p>
Эта функция заполняет части структуры <a href="#lua_Debug"><code>lua_Debug</code></a>
с индентификацией <em>записи активации</em> функции, выполняемой на данном уровне (level).
Уровень&nbsp;0 - это текущая выполняющаяся функция,
уровень <em>n+1</em> - это функция которая вызывает уровень <em>n</em>
(за исключением хвостовых вызовов, которые не считаются на стеке).
Когда ошибок нет, <a href="#lua_getstack"><code>lua_getstack</code></a> возвращает 1;
когда вызвана с уровнем больше чем глубина стека, возвращает 0.


<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Предоставляет информацию о <code>n</code>-ном upvalue замыкания
по индексу <code>funcindex</code>.
Функция ложит на стек значение upvalue и возвращает его имя.
Возвращает <code>NULL</code> (и ничего не ложит на стек),
когда индекс <code>n</code> больше количества upvalue.

<p>
Для C&nbsp;функций, эта функция использует пустую строку <code>""</code>
в качестве имени для всех upvalue.
(Для Lua функций,
upvalue - это внешние локальные переменные, которые использует функция,
и которые, следовательно, включены в её замыкание.)

<p>
Upvalue не имеют конкретного порядка,
как они активны внутри функции.
Они нумеруются в произвольном порядке.


<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
Тип для отладочных функций перехватчиков.

<p>
Всякий раз, когда вызывается перехватчик, его аргумент <code>ar</code>
имеет поле <code>event</code>, установленное согласно событию, вызвавшему срабатывание перехватчика.
Lua идентифицирует эти события следующими константами:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>,
<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>,
<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>
и <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Более того, для событий строк устанавливается поле <code>currentline</code>.
Для получения значений остальных полей в <code>ar</code>,
перехватчик должен вызвать <a href="#lua_getinfo"><code>lua_getinfo</code></a>.

<p>
Для событий вызова, <code>event</code> может быть <code>LUA_HOOKCALL</code> -
нормальное значение, или <code>LUA_HOOKTAILCALL</code> - для хвостового вызова;
в этом случае, соответствующего события возврата не будет.

<p>
Пока Lua выполняет перехватчик, все остальные перехватчики отключаются.
Следовательно, если перехватчик вызывает Lua для выполнения функции или куска,
это выполнение произойдет без вызова перехватчиков.

<p>
Функции перехватчики не могут иметь продолжений,
т.е. они не могут вызывать <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
<a href="#lua_pcallk"><code>lua_pcallk</code></a> или
<a href="#lua_callk"><code>lua_callk</code></a> с не нулевым <code>k</code>.

<p>
Функции перехватчики могут уступать при следующих условиях:
только счетные и события строк могут уступать;
для уступки, функция перехватчик должна завершить свое исполнение,
вызвав <a href="#lua_yield"><code>lua_yield</code></a> с <code>nresults</code> = 0
(т.е. без значений).


<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
Устанавливает отладочную функцию-перехватчик.

<p>
Аргумент <code>f</code> - это функция перехватчик.
<code>mask</code> - определяет на каких событиях будет вызван перехватчик:
формируется битовым ИЛИ констант
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>
и <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
Аргумент <code>count</code> - имеет значение только, когда маска
включает <code>LUA_MASKCOUNT</code>.
Перехватчик для каждого события объясняется ниже:

<ul>

<li><b>Перехватчик вызова (call hook): </b> вызывается, когда интерпретатор вызывает функцию.
Перехватчик вызывается сразу после того, как Lua войдет в новую функцию,
перед тем как функция получит свои аргументы.
</li>

<li><b>Перехватчик возврата (return hook): </b> вызывается, когда интерпретатор возвращается
из функции. Перехватчик вызывается перед тем, как Lua покинет функцию.
Здесь нет стандартного пути для доступа к возвращаемым функцией значениям.
</li>

<li><b>Перехватчик строки (line hook): </b> вызывается, когда интерпретатор начинает выполнение
новой строки кода, или когда он переходит назад в код (даже в ту же строку).
(Это событие случается только пока Lua выполняет Lua функцию.)
</li>

<li><b>Счетный перехватчик (count hook): </b> вызывается после того, как интерпретатор
запустит <code>count</code> инструкций.
(Это событие случается только пока Lua выполняет Lua функцию.)
</li>

</ul>

<p>
Перехват отключается установкой <code>mask</code> = 0.


<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Устанавливает значение локальной переменной в данной записи активации (ar).
Устанавливает переменной значение с вершины стека и возвращает её имя,
затем удаляет значение из стека.

<p>
Возвращает <code>NULL</code> (и ничего не удаляет со стека),
когда индекс больше количества активных локальных переменных.

<p>
Параметры <code>ar</code> и <code>n</code> такие же, как
в функции <a href="#lua_getlocal"><code>lua_getlocal</code></a>.


<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Устанавливает значение для upvalue замыкания.

Устанавливает upvalue равным значению с вершины стека и возвращает её имя,
затем удаляет значение из стека

<p>
Возвращает <code>NULL</code> (и ничего не удаляет со стека),
когда индекс больше количества upvalue.

<p>
Параметры <code>funcindex</code> и <code>n</code> такие же, как
в функции <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>.


<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
Возвращает уникальный идентификатор для upvalue под номером <code>n</code>
из замыкания по индексу <code>funcindex</code>.

<p>
Эти уникальные идентификаторы позволяют программе проверить,
когда замыкания совместно используют upvalue.
Lua замыкания, которые совместно используют upvalue
(т.е., обращаются к одной внешней локальной переменной),
вернут одинаковые идентификаторы для индексов своих upvalue.

<p>
Параметры <code>funcindex</code> и <code>n</code> такие же, как
в функции <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>,
но <code>n</code> не может быть больше количества upvalue.


<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>
<p>
Делает <code>n1</code>-ое upvalue Lua замыкания по индексу <code>funcindex1</code>
ссылкой на <code>n2</code>-ое upvalue Lua замыкания по индексу <code>funcindex2</code>.


<h1>5 &ndash; <a name="5">Вспомогательная библиотека</a></h1>

<p>
<em>Вспомогательная библиотека</em> предоставляет различные удобные функции
для взаимодействия C с Lua.
Когда базовые API предоставляют примитивные функции для всех взаимодействий
между C и Lua,
вспомогательная библиотека предоставляет высокоуровневые функции
для некоторых общих задач.

<p>
Все функции и типы вспомогательной библиотеки
определены в заголовочном файле <code>lauxlib.h</code> и
имеют префикс <code>luaL_</code>.

<p>
Все функции вспомогательной библиотеки строятся из базовых API,
и так они не предоставляют ничего, чего нельзя было бы сделать с
помощью этих API.
Тем не менее, использование вспомогательной библиотеки гарантирует
большую стабильность вашему коду.

<p>
Различные функции вспомогательной библиотеки используют внутри
несколько дополнительных слотов.
Когда функция вспомогательной библиотеки использует меньше пяти слотов,
она не проверяет размер стека;
она просто предполагает, что там достаточно слотов.

<p>
Различные функции вспомогательной библиотеки используются для проверки
аргументов C&nbsp;функций.
Так как сообщение об ошибке формируется для аргументов
(т.е., "<code>bad argument #1</code>"),
вы не должны использовать эти функции для других значений стека.

<p>
Функции <code>luaL_check*</code>
всегда генерируют ошибку, если проверка не удовлетворена.


<h2>5.1 &ndash; <a name="5.1">Функции и типы</a></h2>

<p>
Здесь представлен список всех функций и типов вспомогательной библиотеки
в алфавитном порядке.


<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
Добавляет байт <code>c</code> в буфер <code>B</code>
(см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).


<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
Добавляет строку по указателю <code>s</code> длиной <code>l</code> 
в буфер <code>B</code>
(см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Строка может содержать встроенные нули.


<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
Добавляет в буфер <code>B</code> (см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>)
строку длиной <code>n</code>, прежде скопированную в область буфера
(см. <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>).


<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
Добавляет завершаемую нулем строку по указателю <code>s</code>
в буфер <code>B</code>
(см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).


<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>e</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
Добавляет значение с вершины стека в буфер <code>B</code>
(см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Снимает значение со стека.

<p>
Только эта функция для строковых буферов может (и должна)
вызываться с дополнительным аргументом на стеке,
являющимся значением для добавления в буфер.


<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
Проверяет когда <code>cond</code> истина.
Если это не так, генерирует ошибку со стандартным сообщением
(см. <a href="#luaL_argerror"><code>luaL_argerror</code></a>).


<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
Генерирует ошибку, сообщающую о проблеме с аргументом <code>arg</code>
для C функции, которая вызвала luaL_argerror.
Используется стандартное сообщение, включающее <code>extramsg</code> как комментарий:

<pre>
     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
Эта функция никогда не возвращается.


<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
Тип для <em>строкового буфера</em>.

<p>
Строковый буфер позволяет C&nbsp;коду строить Lua строки по частям.
Обычно он используется следующим образом:

<ul>

<li>Сначала объявляется переменная <code>b</code> типа <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>
<li>Затем она инициализируется вызовом <code>luaL_buffinit(L, &amp;b)</code>.</li>
<li>
Затем части строки добавляются в буфер вызовами функций <code>luaL_add*</code>.
</li>
<li>
Завершается вызовом <code>luaL_pushresult(&amp;b)</code>.
Этот вызов оставляет финальную строку на вершине стека.
</li>

</ul>

<p>
Если вы заранее знаете размер результирующей строки,
вы можете использовать буфер так:

<ul>

<li>Сначала объявляется переменная <code>b</code> типа <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>
<li>Затем вызовом <code>luaL_buffinitsize(L, &amp;b, sz)</code>
она инициализируется, и для неё выделяется память размером <code>sz</code>.</li>
<li>Затем в эту область копируется строка.</li>
<li>
Завершается вызовом <code>luaL_pushresultsize(&amp;b, sz)</code>,
где <code>sz</code> - размер результирующей строки, скопированной в эту область.
</li>

</ul>

<p>
При нормальном управлении,
строковый буфер использует переменное число слотов стека.
Так, пока используется буфер, вы не можете предполагать,
что вы знаете где вершина стека.
Вы можете использовать стек между успешными вызовами буферных операций,
пока он сбалансирован;
т.е., когда вы вызываете буферную операцию,
стек должен быть на том же уровне, что и непосредственно после
предыдущей буферной операции.
(Существует только одно исключение, это <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)
После вызова <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>
стек возвращается на тот уровень, когда был инициализирован буфер,
плюс результирующая строка на вершине.


<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
Инициализирует буфер <code>B</code>.
Эта функция не выделяет память;
буфер должен быть определен как переменная
(см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).


<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
Эквивалентно последовательности
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>,
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>.


<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
Вызывает метаметод.

<p>
Если объект по индексу <code>obj</code> имеет метатаблицу и его метатаблица
имеет поле <code>e</code>,
эта функция вызывает это поле, передавая объект в качестве первого аргумента.
В этом случае функция возвращает true и ложит в стек значение,
возвращенное вызовом метаметода.
Если метатаблицы или метаметода не существует,
функция возвращает false (и ничего не ложит на стек).


<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
Проверяет, что функция имеет аргумент любого типа
(включая <b>nil</b>) по индексу <code>arg</code>.


<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> это целое
(или может быть преобразован в целое),
и возвращает это целое, как <a href="#lua_Integer"><code>lua_Integer</code></a>.


<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> это строка,
и возвращает эту строку;
если <code>l</code> не <code>NULL</code>, пишет в <code>*l</code>
длину строки.

<p>
Эта функция использует <a href="#lua_tolstring"><code>lua_tolstring</code></a>
для получения результата,
так все преобразования и предостережения этой функции относятся и сюда.


<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> это число,
и возвращает это число.


<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> это строка, и ищет эту строку
в массиве <code>lst</code> (который должен завершаться NULL-символом).
Возвращает индекс в массиве, где найдена строка.
Генерирует ошибку, если аргумент не строка или строка не найдена в массиве.

<p>
Если <code>def</code> не <code>NULL</code>,
функция использует <code>def</code> как значение по умолчанию,
когда нет аргумента <code>arg</code> или он равен <b>nil</b>.

<p>
Эта функция полезна для отображения строк в C&nbsp;перечисления (enum).
(Обычно, для выбора опций в Lua библиотеках принято использовать строки вместо чисел.)


<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
Увеличивает размер стека до <code>top + sz</code> элементов,
вызывает ошибку, если стек не может быть увеличен до этого размера.
<code>msg</code> - это дополнительный текст для сообщения об ошибке
(или <code>NULL</code>, если его нет).


<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> это строка,
и возвращает эту строку.

<p>
Эта функция использует <a href="#lua_tolstring"><code>lua_tolstring</code></a>
для получения результата,
так все преобразования и предостережения этой функции относятся и сюда.


<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> имеет тип <code>t</code>.
См. <a href="#lua_type"><code>lua_type</code></a> для кодировок типов <code>t</code>.


<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
Проверяет, что аргумент функции <code>arg</code> это пользовательские данные
типа <code>tname</code> (см. <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>), и
возвращает адрес пользовательских данных (см. <a href="#lua_touserdata"><code>lua_touserdata</code></a>).


<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
Проверяет, что ядро, выполняющее вызов, ядро, создавшее Lua состояние,
и код, производящий вызов, все используют одну версию Lua.
Также проверяет, что ядро, выполняющее вызов, и ядро, создавшее Lua состояние,
используют одно адресное пространство.


<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>e</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
Загружает и запускает данный файл.
Определена как макрос:

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
Возвращает false, если ошибок нет, или true в случае ошибок.


<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Загружает и запускает переданную строку.
Определена как макрос:

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
Возвращает false, если ошибок нет, или true в случае ошибок.


<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
Генерирует ошибку.
Сообщение об ошибке форматируется строкой <code>fmt</code>
и дополнительными аргументами,
следует тем же правилам, что и <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.
Также добавляет в начало сообщения имя файла и номер строки, где произошла ошибка,
если эта информация доступна.

<p>
Эта функция никогда не возвращается,
но её идиома для использования в C&nbsp;функциях:
<code>return luaL_error(<em>args</em>)</code>.


<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>e</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
Эта функция выдает возвращаемые значения для связанных с процессами функций
стандартной библиотеки
(<a href="#pdf-os.execute"><code>os.execute</code></a> и
<a href="#pdf-io.close"><code>io.close</code></a>).


<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>e</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
Эта функция выдает возвращаемые значения для связанных с файлами функций
стандартной библиотеки
(<a href="#pdf-io.open"><code>io.open</code></a>,
<a href="#pdf-os.rename"><code>os.rename</code></a>,
<a href="#pdf-file:seek"><code>file:seek</code></a> и др.).


<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
Ложит на стек поле <code>e</code> из метатаблицы объекта по индексу <code>obj</code>
и возвращает тип положенного на стек значения.
Если объект не имеет метатаблицы или в метатаблице нет этого поля,
ничего не ложит на стек и возвращает <code>LUA_TNIL</code>.


<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
Ложит на стек метатаблицу, ассоциированную с именем <code>tname</code>
в реестре (см. <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>)
(<b>nil</b>, если метатаблицы с таким именем нет).
Возвращает тип положенного на стек значения.


<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
Гарантирует, что значение <code>t[fname]</code> это таблица,
и ложит эту таблицу на стек;
<code>t</code> - это значение по индексу <code>idx</code>.
Возвращает true, если находит существующую таблицу,
и false, если создает новую.


<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
Создает копию строки <code>s</code>, заменяя все вхождения строки <code>p</code>
на строку <code>r</code>.
Ложит на стек результирующую строку и возвращает её.


<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
Возвращает "длину" значения по индексу index как число;
эквивалентна Lua оператору '<code>#</code>' (см. <a href="#3.4.7">&sect;3.4.7</a>).
Генерирует ошибку, если результат операции не целое.
(Это может случиться только через метаметоды.)


<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
Эквивалентно <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>
с <code>mode</code> = <code>NULL</code>.


<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
Загружает буфер как Lua кусок.
Эта функция использует <a href="#lua_load"><code>lua_load</code></a>
для загрузки куска в буфер <code>buff</code> размером <code>sz</code>.

<p>
Функция возвращает те же результаты, что и <a href="#lua_load"><code>lua_load</code></a>.
<p>
<code>name</code> - имя куска, используемое для отладочной информации и сообщений об ошибках.
Строка <code>mode</code> работает как в функции <a href="#lua_load"><code>lua_load</code></a>.


<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
Эквивалентно <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>
с <code>mode</code> = <code>NULL</code>.


<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
Загружает файл как Lua кусок.
Эта функция использует <a href="#lua_load"><code>lua_load</code></a>
для загрузки куска из файла <code>filename</code>.
Если <code>filename</code> = <code>NULL</code>,
загружает кусок из потока стандартного ввода.
Первая линия файла игнорируется, если она начинается с <code>#</code>.

<p>
Строка <code>mode</code> работает как в функции <a href="#lua_load"><code>lua_load</code></a>.

<p>
Эта функция возвращает те же результаты, что и <a href="#lua_load"><code>lua_load</code></a>,
но имеет дополнительный код ошибки <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>,
если не может открыть/прочитать файл или файл имеет неверный режим.

<p>
Как и <a href="#lua_load"><code>lua_load</code></a>,
эта функция только загружает кусок; но не запускает его.


<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
Загружает строку как Lua кусок.
Эта функция использует <a href="#lua_load"><code>lua_load</code></a>
для загрузки завершаемой нулем строки <code>s</code>.

<p>
Эта функция возвращает те же результаты, что и <a href="#lua_load"><code>lua_load</code></a>.

<p>
Как и <a href="#lua_load"><code>lua_load</code></a>,
эта функция только загружает кусок; но не запускает его.


<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Создает новую таблицу и регистрирует в ней функции из списка <code>l</code>.

<p>
Реализована как макрос:

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
Массив <code>l</code> должен быть фактическим массивом,
не указателем на него.


<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Создает новую таблицу с размером, оптимизированным для хранения всех записей
массива <code>l</code>
(но фактически не сохраняет их).
Она предполагается для использования в связке с <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
(см. <a href="#luaL_newlib"><code>luaL_newlib</code></a>).

<p>
Реализована как макрос.
Массив <code>l</code> должен быть фактическим массивом,
не указателем на него.


<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
Если реестр уже содержит ключ <code>tname</code>, возвращает 0.
Иначе, создает новую таблицу для использования в качестве метатаблицы
пользовательских данных,
добавляет в эту новую таблицу пару <code>__name = tname</code>,
добавляет в реестр пару <code>[tname] = new table</code>,
и возвращает 1.
(Элемент <code>__name</code> используется некоторыми функциями, сообщающими об ошибках.)

<p>
В обоих случаях ложит на стек финальное значение ассоциированное с
<code>tname</code> в реестре.


<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
Создает новое Lua состояние.
Вызывает <a href="#lua_newstate"><code>lua_newstate</code></a> с функцией выделения
памяти, базирующейся на стандартной &nbsp;C функции <code>realloc</code>,
и затем устанавливает функцию паники (см. <a href="#4.6">&sect;4.6</a>),
которая в случае фатальных ошибок
печатает сообщение об ошибке в стандартный поток вывода.

<p>
Возвращает новое состояние, или <code>NULL</code>,
если не удалось выделить память.


<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
Открывает все стандартные библиотеки Lua в данное состояние.


<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
Если аргумент функции <code>arg</code> это целое
(или может быть преобразован в целое), возвращает это целое.
Если аргумент отсутствует или равен <b>nil</b>, возвращает <code>d</code>.
Иначе, генерирует ошибку.


<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
Если аргумент функции <code>arg</code> это строка,
возвращает эту строку.
Если аргумент отсутствует или равен <b>nil</b>, возвращает <code>d</code>.
Иначе, генерирует ошибку.

<p>
Если <code>l</code> не <code>NULL</code>,
записывает в <code>*l</code> длину результата.


<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
Если аргумент функции <code>arg</code> это число,
возвращает это число.
Если аргумент отсутствует или равен <b>nil</b>, возвращает <code>d</code>.
Иначе, генерирует ошибку.


<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
Если аргумент функции <code>arg</code> это строка,
возвращает эту строку.
Если аргумент отсутствует или равен <b>nil</b>, возвращает <code>d</code>.
Иначе, генерирует ошибку.


<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
Эвивалентно <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
с предопределенным размером <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>.


<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Возвращает адрес пространства размером <code>sz</code>,
куда вы можете скопировать строку, чтобы добавить в буфер <code>B</code>
(см. <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
После копирования строки в это пространство, вы должны вызвать
<a href="#luaL_addsize"><code>luaL_addsize</code></a>
с размером строки, для фактического добавления её в буфер.


<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
Завершает использование буфера <code>B</code>,
оставляя финальную строку на вершине стека.


<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Эквивалентно последовательности <a href="#luaL_addsize"><code>luaL_addsize</code></a>,
<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>.


<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
Создает и возвращает <em>ссылку</em> (reference) в таблице по индексу <code>t</code>,
для объекта на вершине стека (и снимает этот объект со стека).

<p>
Ссылка это уникальный целый ключ.
Пока вы не добавляете целые ключи в таблицу <code>t</code>,
<a href="#luaL_ref"><code>luaL_ref</code></a> гарантирует уникальность возвращаемых ключей.
Вы можете извлечь объект по ссылке <code>r</code>, вызвав <code>lua_rawgeti(L, t, r)</code>.
Функция <a href="#luaL_unref"><code>luaL_unref</code></a>
освобождает ссылку и ассоциированный с ней объект.

<p>
Если объект на вершине стека равен <b>nil</b>,
<a href="#luaL_ref"><code>luaL_ref</code></a> возвращает константу
<a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>.
Константа <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> всегда отлична
от любой другой ссылки, возвращаемой <a href="#luaL_ref"><code>luaL_ref</code></a>.


<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
Тип для массивов функций для регистрации функцией <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>.
<code>name</code> - имя функции, <code>func</code> - указатель на функцию.
Любой массив <a href="#luaL_Reg"><code>luaL_Reg</code></a>
должен завершаться ключевым элементом, в котором <code>name</code> и <code>func</code> = <code>NULL</code>.


<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
Если <code>modname</code> ещё не присутствует в <a href="#pdf-package.loaded"><code>package.loaded</code></a>,
вызывает функцию <code>openf</code> со строкой <code>modname</code> в качестве аргумента
и пишет результат вызова в <code>package.loaded[modname]</code>,
как если бы эта функция была бы вызвана через <a href="#pdf-require"><code>require</code></a>.

<p>
Если <code>glb</code> = true,
также сохраняет модуль в глобальную <code>modname</code>.

<p>
Оставляет копию модуля на стеке.


<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>e</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
Регистрирует все функции в массиве <code>l</code>
(см. <a href="#luaL_Reg"><code>luaL_Reg</code></a>)
в таблицу на вершине стека (ниже опциональных upvalue, см. далее).

<p>
Когда <code>nup</code> != 0,
все функции создаются, разделяющими <code>nup</code> upvalue,
которые должны быть предварительно положены на стек
поверх таблицы библиотеки.
После регистрации эти значения снимаются со стека.


<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
Устанавливает метатаблицей объекта на вершине стека
метатаблицу, ассоциированную с именем <code>tname</code>
в реестре (см. <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).


<hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
Стандартное представление для описателей файлов (handle),
которые используются стандартной библиотекой ввода-вывода.

<p>
Описатель файла реализован как полные пользовательские данные,
с метатаблицей называемой <code>LUA_FILEHANDLE</code>
(где <code>LUA_FILEHANDLE</code> - это макрос с фактическим именем метатаблицы).
Метатаблица создается библиотекой  ввода-вывода
(см. <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).

<p>
Эти пользовательские данные должны начинаться со структуры <code>luaL_Stream</code>;
они могут содержать другие данные после этой начальной структуры.
Поле <code>f</code> - указывает на соответствующий C поток
(ими может быть <code>NULL</code> для индикации не полностью созданного описателя).
Поле <code>closef</code> - указывает на Lua функцию,
которая будет вызвана для закрытия потока,
при закрытии или сборке описателя;
эта функция получает описатель файла в качестве единственного аргумента и
должна вернуть <b>true</b> (в случае успеха) или
<b>nil</b> с сообщением об ошибке (в случае ошибки).
Как только Lua вызывает это поле,
его значение меняется на <code>NULL</code>
для сигнализации, что описатель закрыт.


<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
Эта функция работает как <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>,
за исключением того, что когда проверка неудачна, она возвращает <code>NULL</code>,
вместо генерирования ошибки.


<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
Конвертирует любое Lua значение по индексу idx в C&nbsp;строку
в разумном формате.
Результирующая строка ложится на стек и также возвращается функцией.
Если <code>len</code> не <code>NULL</code>,
функция пишет в <code>*len</code> длину строки.

<p>
Если значение имеет метатаблицу с полем <code>"__tostring"</code>,
то <code>luaL_tolstring</code> вызывает соответствующий метаметод
со значением в качестве аргумента
и использует результат вызова, как свой результат.


<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
Создает и ложит на стек трассировку стека <code>L1</code>.
Если <code>msg</code> не <code>NULL</code>, оно добавляется
в начало трассировки.
Параметр <code>level</code> указывает на каком уровне начинать трассировку.


<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
Возвращает имя типа для значения по индексу index.


<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
Освобождает ссылку <code>ref</code> из таблицы по индексу <code>t</code>
(см. <a href="#luaL_ref"><code>luaL_ref</code></a>).
Элемент удаляется из таблицы,
так что ассоциированный объект может быть собран сборщиком мусора.
Ссылка <code>ref</code> также освобождается для повторного использования.

<p>
Если <code>ref</code> = <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a>
или <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>,
<a href="#luaL_unref"><code>luaL_unref</code></a> ничего не делает.


<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
Ложит на стек строку, идентифицирующую текущую позицию
на управляющем уровне <code>lvl</code> в стеке вызовов.
Обычно эта строка имеет следующий формат:

<pre>
     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
Уровень&nbsp;0 - это текущая выполняемая функция,
уровень&nbsp;1 - это функция, которая вызвала текущую,
и так далее.

<p>
Эта функция используется для формирования префикса сообщений об ошибках.


<h1>6 &ndash; <a name="6">Стандартные библиотеки</a></h1>

<p>
Стандартные библиотеки Lua предоставляют полезные функции,
реализованные напрямую через C&nbsp;API.
Некоторые из этих функций предоставляют существенные службы языка
(например, <a href="#pdf-type"><code>type</code></a> и <a href="#pdf-getmetatable"><code>getmetatable</code></a>);
другие предоставляют доступ к "внешним" сервисам (например, I/O);
и другие могут быть реализованы в Lua самостоятельно,
но очень полезны и имеют критические требования к производительности,
что заслуживает реализации в C (например, <a href="#pdf-table.sort"><code>table.sort</code></a>).

<p>
Все библиотеки реализованы через официальный C&nbsp;API
и предоставляются, как отдельные C&nbsp;модули.
Lua имеет следующие стандартные библиотеки:

<ul>

<li>базовая библиотека (<a href="#6.1">&sect;6.1</a>);</li>
<li>библиотека сопрограмм (<a href="#6.2">&sect;6.2</a>);</li>
<li>библиотека пакетов (<a href="#6.3">&sect;6.3</a>);</li>
<li>манипуляции со строками (<a href="#6.4">&sect;6.4</a>);</li>
<li>базовая поддержка UTF-8 (<a href="#6.5">&sect;6.5</a>);</li>
<li>манипуляции с таблицами (<a href="#6.6">&sect;6.6</a>);</li>
<li>математические функции (<a href="#6.7">&sect;6.7</a>) (sin, log и др.);</li>
<li>ввод и вывод (<a href="#6.8">&sect;6.8</a>);</li>
<li>средства операционной системы (<a href="#6.9">&sect;6.9</a>);</li>
<li>отладочные средства (<a href="#6.10">&sect;6.10</a>).</li>

</ul><p>
За исключением базовой и пакетной библиотек,
каждая библиотека предоставляет все свои функции, как поля глобальной таблицы
или методы её объектов.

<p>
Для получения доступа к этим библиотекам
хоствая C&nbsp;программа должна вызвать функцию <a href="#luaL_openlibs"><code>luaL_openlibs</code></a>,
которая открывает все стандартные библиотеки.
Либо, хостовая программа может открыть их индивидуально, используя
<a href="#luaL_requiref"><code>luaL_requiref</code></a> для вызова
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> (для базовой библиотеки),
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> (для библиотеки пакетов),
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> (для библиотеки сопрограмм),
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> (для строковой библиотеки),
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a> (для библиотеки UTF8),
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> (для табличной библиотеки),
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> (для математической библиотеки),
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> (для библиотеки ввода-вывода),
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> (для библиотеки операционной системы)
и <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (для отладочной библиотеки).
Все эти функции определены в <a name="pdf-lualib.h"><code>lualib.h</code></a>.


<h2>6.1 &ndash; <a name="6.1">Базовые функции</a></h2>

<p>
Базовая библиотека предоставляет функции ядра для Lua.
Если вы не включите эту библиотеку в ваше приложение,
вы должны проявлять осторожность, когда будете нуждаться в предоставлении
реализаций для некоторых её возможностей.

<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>

<p>
Вызывает <a href="#pdf-error"><code>error</code></a>, если значение
аргумента <code>v</code> = false (т.е., <b>nil</b> или <b>false</b>);
иначе, возвращает все свои аргументы.
В случае ошибки,
<code>message</code> - это объект ошибки;
когда он отсутствует, его значение по умолчанию "<code>assertion failed!</code>"


<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>

<p>
Эта функция общий интерфейс к сборщику мусора.
Она выполняет различные действия в соответствии с её аргументом <code>opt</code>:

<ul>

<li><b>"<code>collect</code>": </b>
выполняет полный цикл очистки мусора. Это опция по умолчанию.
</li>

<li><b>"<code>stop</code>": </b>
останавливает автоматическое выполнение сборщика мусора.
Сборщик будет запущен, только когда явно вызван, до вызова его перезапуска.
</li>

<li><b>"<code>restart</code>": </b>
перезапускает автоматическое выполнение сборщика мусора.
</li>

<li><b>"<code>count</code>": </b>
возвращает общее количество используемой Lua памяти в килобайтах.
Это значение имеет дробную часть,
так что его произведение на 1024 дает точное количство байт,
используемых Lua (за исключением переполнений).
</li>

<li><b>"<code>step</code>": </b>
выполняет шаг сборки мусора.
"Размер" шага контролируется аргументом <code>arg</code>.
С нулевым значением сборщик выполнит один базовый (неделимый) шаг.
Для не нулевых значений,
сборщик выполнит, как если это количество памяти (в килобайтах)
было выделено Lua.
Возвращает <b>true</b>, если шаг завершил цикл сборки.
</li>

<li><b>"<code>setpause</code>": </b>
устанавливает <code>arg</code> в качестве нового значения для <em>паузы</em>
сборщика (см. <a href="#2.5">&sect;2.5</a>).
Возвращает предыдущее значение <em>паузы</em>.
</li>

<li><b>"<code>setstepmul</code>": </b>
устанавливает <code>arg</code> в качестве нового значения для
<em>множителя шагов</em> сборщика (см. <a href="#2.5">&sect;2.5</a>).
Возвращает предыдущее значение <em>шага</em>.
</li>

<li><b>"<code>isrunning</code>": </b>
возвращает логическое значение, говорящее запущен ли сборщик
(т.е. не остановлен).
</li>

</ul>


<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
Открывает файл и запускает его содержимое, как Lua кусок.
Когда вызвана без аргументов, запускает содержимое стандартного ввода (<code>stdin</code>).
Возвращает все значения, возвращенные куском.
В случае ошибок, <code>dofile</code> распространяет ошибку вызывающему коду
(т.е. <code>dofile</code> не запускается в защищенном режиме).


<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
Завершает последнюю защищенно вызванную функцию и
возвращает <code>message</code>, как объект ошибки.
Функция <code>error</code> никогда не возвращается.

<p>
Обычно <code>error</code> добавляет информацию о позиции ошибки
в начало сообщения, если сообщение (message) это строка.
Аргумент <code>level</code> определяет как получить позицию ошибки.
Когда level&nbsp;=&nbsp;1 (по умолчанию) - позиция ошибки там, где вызвана функция <code>error</code>.
Level&nbsp;=&nbsp;2 - указывает ошибку там, где вызвана функция, вызвавшая <code>error</code>;
и так далее.
Передача level&nbsp;=&nbsp;0 - позиция ошибки не влючается в сообщение.


<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
Глобальная переменная (не функция), которая хранит глобальное окружение
(см. <a href="#2.2">&sect;2.2</a>).
Lua сама не использует эту переменную;
её изменение не влияет на окружение, ни наоборот.


<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>

<p>
Если <code>object</code> не имеет метатаблицы, возвращает <b>nil</b>.
Иначе, если метатаблица объекта имеет поле <code>"__metatable"</code>,
возвращает ассоциированное с этим полем значение.
Иначе, возвращает метатаблицу переданного объекта.


<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>

<p>
Возвращет три значения (функцию итератор, таблицу <code>t</code> и 0),
так что конструкция

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
будет перебирать пары ключ&ndash;значение
(<code>1,t[1]</code>), (<code>2,t[2]</code>), ...,
до первого значения nil.


<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>

<p>
Загружает кусок.

<p>
Если <code>chunk</code> это строка, кусок будет этой строкой.
Если <code>chunk</code> это функция,
<code>load</code> многократно вызывает её, чобы получить части куска.
Каждый вызов <code>chunk</code> должен возвращать строку, которая
присоединяется к предыдущим результатам.
Возврат пустой строки, <b>nil</b> или ничего сигнализирует о конце куска.

<p>
Если в куске нет синтаксических ошибок,
возвращает скомпилированный кусок, как функцию;
иначе, возвращает <b>nil</b> и сообщение об ошибке.

<p>
Если результирующая функция имеет upvalue,
первое upvalue устанавливается равным <code>env</code>, если этот параметр передан,
или в значение глобального окружения.
Остальные upvalue инициализируются значением <b>nil</b>.
(Когда вы загружаете главный кусок,
результирующая функция всегда будет иметь только одно upvalue,
переменную <code>_ENV</code> (см. <a href="#2.2">&sect;2.2</a>).
Тем не менее, когда вы загружаете бинарный кусок, созданный из функции
(см. <a href="#pdf-string.dump"><code>string.dump</code></a>),
результирующая функция может иметь произвольное количество upvalue.)
Все upvalue свежие, т.е. они не разделяются между любыми другими функциями.

<p>
<code>chunkname</code> - используется как имя куска, для сообщений об ошибках
и отладочной информации (см. <a href="#4.9">&sect;4.9</a>).
Когда отсутствует, его значение по умолчанию это сам <code>chunk</code>,
если <code>chunk</code> это строка,
или "<code>=(load)</code>" иначе.

<p>
Строка <code>mode</code> - управляет каким может быть кусок, текстовым или бинарным
(т.е. прекомпилированным).
Она может быть "<code>b</code>" (только бинарные куски),
"<code>t</code>" (только текстовые куски)
или "<code>bt</code>" (текстовые и бинарные куски).
Значение по умолчанию это "<code>bt</code>".

<p>
Lua не проверяет правильность бинарных кусков.
Злонамеренно созданный бинарный кусок может разрушить интерпретатор.


<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>

<p>
Аналогично <a href="#pdf-load"><code>load</code></a>,
но получает кусок из файла <code>filename</code>
или из стандартного потока ввода, если имя файла не передано.


<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>

<p>
Позволяет программе просмостреть все поля таблицы.
Её первый аргумент - это таблица, второй аргумент - индекс в этой таблице.
<code>next</code> возвращает следующий индекс таблицы и ассоциированное с ним значение.
Когда вызывается с <b>nil</b> в качестве второго аргумента,
<code>next</code> возвращает начальный индекс и ассоциированое с ним значение.
Когда вызывается с последним индексом, или с <b>nil</b> для пустой таблицы,
<code>next</code> возвращает <b>nil</b>.
Если второй аргумет отсутствует, то он интерпретируется как <b>nil</b>.
В частности, вы можете использовать <code>next(t)</code>
для проверки, что таблица пустая.

<p>
Порядок перечисления индексов не определен,
<em>даже для числовых индексов</em>.
(Для просмотра таблицы в числовом порядке, используйте числовой <b>for</b>.)

<p>
Поведение <code>next</code> неопределено, если во время просмотра
вы присваиваете любое значение несуществующему полю в таблице.
Тем не менее вы можете модифицировать существующие поля.
В частности, вы можете очищать существующие поля.


<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>

<p>
Если <code>t</code> имеет метаметод <code>__pairs</code>,
вызывает его с аргументом <code>t</code> и возвращает первые три результата вызова.

<p>
Иначе, возвращает три значения:
функцию <a href="#pdf-next"><code>next</code></a>, таблицу <code>t</code> и <b>nil</b>,
так что конструкция

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
будет перебирать все пары ключ&ndash;значение в таблице <code>t</code>.

<p>
См. функцию <a href="#pdf-next"><code>next</code></a>
для предострежений о модификации таблицы во время просмотра.


<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>

<p>
Вызывает функцию <code>f</code> с переданными аргументами в <em>защищенном режиме</em>.
Это значит, что любая ошибка внутри&nbsp;<code>f</code> не распространяется;
взамен, <code>pcall</code> перехватывает ошибку и возвращает код статуса.
Её первый результат - код статуса (логическое значение),
которое равно true, если вызов успешен.
В этом случае <code>pcall</code> также возвращает все результаты из вызова,
после первого результата.
В случае ошибки <code>pcall</code> возвращает false и сообщение об ошибке.


<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
Получает произвольное количество аргументов и печатает их значения в <code>stdout</code>,
используя функцию <a href="#pdf-tostring"><code>tostring</code></a>
для преобразования каждого аргумента в строку.
<code>print</code> не предназначен для форматированного вывода,
только как быстрый способ показать значение, например, для отладки.
Для полного контроля над выводом используйте
<a href="#pdf-string.format"><code>string.format</code></a> и
<a href="#pdf-io.write"><code>io.write</code></a>.


<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
Проверяет, что <code>v1</code> равен <code>v2</code>,
без вызова метаметодов.
Возвращает логическое значение.


<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
Возвращает реальное значение <code>table[index]</code>,
без вызова метаметодов.
<code>table</code> должен быть таблицей,
<code>index</code> может быть любым значением.


<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
Возвращает длину объекта <code>v</code>,
который должен быть таблицей или строкой,
без вызова метаметодов. Возвращает целое.


<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
Устанавливает реальное значение <code>table[index]</code> равным <code>value</code>,
без вызова метаметодов.
<code>table</code> должен быть таблицей,
<code>index</code> - любое значение отличное от <b>nil</b> и NaN,
<code>value</code> - любое Lua значение.

<p>
Эта функция возвращает <code>table</code>.


<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>

<p>
Если <code>index</code> это число,
возвращает все аргументы после аргумента номер <code>index</code>;
негативное число индексируется с конца (-1 последний аргумент).
Иначе, если <code>index</code> строка <code>"#"</code>,
<code>select</code> вернет общее количество дополнительных аргументов.


<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>

<p>
Устанавливает метатаблицу для данной таблицы.
(Вы не можете изменять метатаблицы других типов из Lua, только из&nbsp;C.)
Если <code>metatable</code> = <b>nil</b>,
удаляет метатаблицу переданной таблицы.
Если оригинальная метатаблица имеет поле <code>"__metatable"</code>,
генерирует ошибку.

<p>
Эта функция возвращает <code>table</code>.


<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>

<p>
Когда вызвана без аргумента <code>base</code>,
<code>tonumber</code> пытается конвертировать аргумент в число.
Если аргумент уже число или строка, которую можно преобразовать в число,
то <code>tonumber</code> возвращает это число;
иначе, возвращает <b>nil</b>.

<p>
Преобразование строк может выдавать в результате целые или вещественные числа,
в соответствии с лексическими соглашениями Lua (см. <a href="#3.1">&sect;3.1</a>).
(Строка может иметь начальные и конечные пробелы и знак.)

<p>
Когда вызвана с аргументом <code>base</code>,
то аргумент <code>e</code> должен быть строкой, которая интерпретируется как целое
в данной системе счисления.
base может быть любым целым от 2 до 36, включительно.
При base >&nbsp;10, символ '<code>A</code>' (в верхнем или нижнем регистре)
представляет&nbsp;10, '<code>B</code>' представляет&nbsp;11 и так далее,
с '<code>Z</code>' представляющим 35.
Если строка <code>e</code> не правильное число в данной системе счисления,
функция возвращает <b>nil</b>.


<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
Получает значение любого типа и преобразует его в строку
в понятном человеку формате.
(Для полного контроля над преобразованием чисел используйте
<a href="#pdf-string.format"><code>string.format</code></a>.)

<p>
Если метатаблица <code>v</code> имеет поле <code>"__tostring"</code>,
то <code>tostring</code> вызывает соответствующее значение
с <code>v</code> в качестве аргумента
и использует результат вызова, как свой результат.


<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
Возвращает тип любого аргумента, представленный строкой.
Возможные результаты этой функции:
"<code>nil</code>" (строка, не значение <b>nil</b>),
"<code>number</code>",
"<code>string</code>",
"<code>boolean</code>",
"<code>table</code>",
"<code>function</code>",
"<code>thread</code>"
и "<code>userdata</code>".


<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
Глобальная переменная (не функция), которая содержит строку с текущей версией интерпретатора.
Текущее значение этой переменной "<code>Lua 5.3</code>".


<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>

<p>
Эта функция похожа на <a href="#pdf-pcall"><code>pcall</code></a>,
но она устанавливает новый обработчик сообщений <code>msgh</code>.



<h2>6.2 &ndash; <a name="6.2">Работа с сопроцессами</a></h2>

<p>
Эта библиотека содержит операции для манипуляции с сопроцессами,
которые хранятся в таблице <a name="pdf-coroutine"><code>coroutine</code></a>.
См. <a href="#2.6">&sect;2.6</a> для общего описания сопроцессов.


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>

<p>
Создает новый сопроцесс, с телом <code>f</code>.
<code>f</code> должен быть функцией.
Возвращает этот новый сопроцесс, как объект с типом <code>"thread"</code>.


<p>
<hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ()</code></a></h3>

<p>
Возвращает true, когда запущенный сопроцесс может уступить.

<p>
Запущенный сопроцесс может уступать, если это не главный поток и
он не внутри неприостанавливаемой C функции.


<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>

<p>
Начинает или продолжает выполнение сопроцесса <code>co</code>.
При первом возобновлении сопроцесса запускает его тело.
Значение <code>val1</code>, ... передаются как аргументы телу сопроцесса (его функции).
Если сопроцесс был приостановлен,
<code>resume</code> перезапускает его;
значниния <code>val1</code>, ... передаются как результаты из yield.

<p>
Если сопроцесс запущен без ошибок,
<code>resume</code> возвращает <b>true</b> и все значения, переданные в <code>yield</code>
(когда сопроцесс уступает) или все значения, возвращенные функцией сопроцесса
(когда сопроцесс завершается).
В случае ошибок,
<code>resume</code> возвращает <b>false</b> и сообщение об ошибке.


<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>

<p>
Возвращает запущенный сопроцесс и логическое значение;
true, если сопроцесс это главный поток.


<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>

<p>
Возвращает статус сопроцесса <code>co</code>, как строку:
<code>"running"</code> - сопроцесс запущен (т.е. он вызвал <code>status</code>);
<code>"suspended"</code> - сопроцесс приостановлен в вызове <code>yield</code> или еще не запущен;
<code>"normal"</code> - сопроцесс активен, но не выполняется (т.е. он был продолжен другим сопроцессом);
<code>"dead"</code> - сопроцесс завершил своё тело или был остановлен с ошибкой.


<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>

<p>
Создает новый сопроцесс с телом <code>f</code>.
<code>f</code> должен быть функцией.
Возвращает функцию, которая возобновляет сопроцесс при каждом её вызове.
Все аргументы, переданные этой функции, 
ведут себя как дополнительные аргументы в <code>resume</code>.
Возвращает те же значения, что и <code>resume</code>,
за исключением первого логического значения.
В случае ошибки, распространяет ошибку.


<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>

<p>
Приостанавливает выполнение вызывающего сопроцесса.
Все аргументы <code>yield</code> передаются, как дополнительные результаты в <code>resume</code>.



<h2>6.3 &ndash; <a name="6.3">Модули</a></h2>

<p>
Эта пакетная библиотека предоставляет базовые возможности для загрузки модулей в Lua.
Она экспортирует одну функцию напрямую в глобальное окружение:
<a href="#pdf-require"><code>require</code></a>.
Всё остальное экспортируется в таблице <a name="pdf-package"><code>package</code></a>.


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>

<p>
Загружает переданный модуль.
Функция начинает с просмотра таблицы <a href="#pdf-package.loaded"><code>package.loaded</code></a>
для определения, что модуль <code>modname</code> уже загружен.
Если это так, то <code>require</code> возвращает значение, хранящееся в <code>package.loaded[modname]</code>.
Иначе, пробует найти <em>загрузчик</em> для модуля.

<p>
При поиске загрузчика
<code>require</code> руководствуется последовательностью
<a href="#pdf-package.searchers"><code>package.searchers</code></a>.
Изменяя эту последовательность,
вы можете изменить то, как <code>require</code> ищет модуль.
Следующее объяснение базируется на конфигурации по умолчанию
для <a href="#pdf-package.searchers"><code>package.searchers</code></a>.

<p>
Сначала <code>require</code> запрашивает <code>package.preload[modname]</code>.
Если это значение существует, то
это значение (которое может быть функцией) это загрузчик.
Иначе <code>require</code> ищет Lua загрузчик, используя путь,
хранящийся в <a href="#pdf-package.path"><code>package.path</code></a>.
Если это тоже неудачно, она ищет C&nbsp;загрузчик, используя путь,
хранящийся в <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
Если и это неудачно, пробует <em>все в одном</em> загрузчик
(см. <a href="#pdf-package.searchers"><code>package.searchers</code></a>).

<p>
Как только загрузчик найден,
<code>require</code> вызывает загрузчик с двумя аргументами:
<code>modname</code> и дополнительное значение, зависящее от того, как получен загрузчик.
(Если загрузчик пришел из файла, это дополнительное значение будет именем файла.)
Если загрузчик возвращает не-nil значение,
<code>require</code> записывает возвращенное значение в <code>package.loaded[modname]</code>.
Если загрузчик не вернул не нулевое значение и 
<code>package.loaded[modname]</code> не присвоено никакое значение,
то <code>require</code> пишет туда <b>true</b>.
В любом случае, <code>require</code> возвращает
финальное значение <code>package.loaded[modname]</code>.

<p>
Если во время загрузки или запуска модуля происходит ошибка,
или если не найден ни один загрузчик для модуля,
<code>require</code> генерирует ошибку.


<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>

<p>
Строка описывающая некоторые конфигурации времени компиляции для пакетов.
Эта строка (string) состоит из последовательности строк (line):

<ul>

<li>Первая строка - это строка разделитель директорий.
По умолчанию, это '<code>\</code>' для Windows и '<code>/</code>' для всех остальных систем.</li>

<li>Вторая строка - символ, который разделяет шаблоны в пути.
По умолчанию это '<code>;</code>'.</li>

<li>Третья строка - это строка, которая обозначает точки замены в шаблоне.
По умолчанию это '<code>?</code>'.</li>

<li>Четвертая строка - это строка, которая в пути в Windows,
заменяется на директорию исполняемого файла.
По умолчанию это '<code>!</code>'.</li>

<li>Пятая строка - это метка для игнорирования всего текста после неё,
когда формируется имя функции <code>luaopen_</code>.
По умолчанию это '<code>-</code>'.</li>

</ul>


<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>

<p>
Этот путь используется <a href="#pdf-require"><code>require</code></a> для поиска C&nbsp;загрузчика.

<p>
Lua инициализирует C&nbsp;путь <a href="#pdf-package.cpath"><code>package.cpath</code></a> также,
как и Lua путь <a href="#pdf-package.path"><code>package.path</code></a>,
используя переменную окружения <a name="pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a>
или переменную окружения <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>
или путь по умолчанию, определенный в <code>luaconf.h</code>.


<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>

<p>
Таблица, используемая <a href="#pdf-require"><code>require</code></a>
для контроля за тем, какие модули уже загружены.
Когда вы загружаете модуль <code>modname</code> и
<code>package.loaded[modname]</code> не false,
<a href="#pdf-require"><code>require</code></a> просто возвращает
хранящееся там значение.

<p>
Эта переменная только ссылка на реальную таблицу;
присваивание этой переменной не изменяет таблицу, используемую
функцией <a href="#pdf-require"><code>require</code></a>.


<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>

<p>
Динамически связывает (link) хостовую программу с C&nbsp;библиотекой <code>libname</code>.

<p>
Если <code>funcname</code> = "<code>*</code>",
то она только связывает с библиотекой,
делая экспортируемые библиотекой символы доступными для других динамических библиотек.
Иначе, она ищет функцию <code>funcname</code> внутри библиотеки
и возвращает эту функцию, как C&nbsp;функцию.
Так, <code>funcname</code> должна соответствовать прототипу
<a href="#lua_CFunction"><code>lua_CFunction</code></a>
(см. <a href="#lua_CFunction"><code>lua_CFunction</code></a>).

<p>
Это низкоуровневая функция.
Она полностью обходит систему пакетов и модулей.
В отличие от <a href="#pdf-require"><code>require</code></a>,
она не производит поисков пути и не добавляет расширения автоматически.
<code>libname</code> должен быть завершенным именем файла C&nbsp;библиотеки,
включая, если необходимо, путь и расширение.
<code>funcname</code> должен быть точным именем, экспортируемым C&nbsp;библиотекой
(которое может зависеть от используемого C&nbsp;компилятора и компоновщика).

<p>
Эта функция не поддерживается стандартным&nbsp;C.
Т.к., она доступна только для некоторых платформ
(Windows, Linux, Mac OS X, Solaris, BSD
и другие Unix системы, которые поддерживаю стандарт <code>dlfcn</code>).


<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>

<p>
Этот путь используется <a href="#pdf-require"><code>require</code></a> для поиска Lua&nbsp;загрузчика.

<p>
Во время запуска Lua инициализирует эту переменную значением переменной окружения
<a name="pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a> или
переменной окружения <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a>, или
значением по умолчанию, определенным в <code>luaconf.h</code>,
если эти переменные окружения не определены.
Любое "<code>;;</code>" в значении переменной окружения
заменяется путем по умолчанию.


<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>

<p>
Таблица для хранения загрузчиков для специфических модулей
(см. <a href="#pdf-require"><code>require</code></a>).

<p>
Эта переменная только ссылается на реальную таблицу;
присваиваение этой переменной не изменяет таблицу,
используемую функцией <a href="#pdf-require"><code>require</code></a>.


<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>

<p>
Таблица, используемая <a href="#pdf-require"><code>require</code></a>
для контроля над тем, как загружать модули.

<p>
Каждый элемент в этой таблице это <em>функция искатель (searcher)</em>.
Когда ищется модуль,
<a href="#pdf-require"><code>require</code></a>
вызывает каждую из этих функций в возрастающем порядке,
с именем модуля (аргумент переданный в <a href="#pdf-require"><code>require</code></a>)
в качестве единственного параметра.
Функция может вернуть другую функцию (<em>загрузчик</em> модуля)
и дополнительное значение, которое будет передано загрузчику,
или строку, объясняющую, почему модуль не найден
(или <b>nil</b> если нечего сказать).

<p>
Lua инициализирует эту таблицу четырьмя функциями искателями.

<p>
первый искатель просто ищет загрузчик в таблице
<a href="#pdf-package.preload"><code>package.preload</code></a>.

<p>
Втрой искатель ищет загрузчик для Lua библиотеки,
используя путь <a href="#pdf-package.path"><code>package.path</code></a>.
Поиск производится как описано в функции <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.

<p>
Третий искатель ищет загрузчик для C&nbsp;библиотеки,
используя путь <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
Поиск производится как описано в функции <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.
Например,
если C&nbsp;путь это строка

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
искатель для модуля <code>foo</code>
будет пробовать открыть файлы <code>./foo.so</code>, <code>./foo.dll</code>,
и <code>/usr/local/foo/init.so</code>, в этом порядке.
Когда он найдет C&nbsp;библиотеку,
сначала он использует средства динамического связывания с библиотекой.
Затем попытается найти в библиотеке C&nbsp;функцию для использования
в качестве загрузчика.
Имя этой C&nbsp;функции это строка "<code>luaopen_</code>",
склеенная с копией имени модуля, где каждая точка заменена на подчеркивание.
Более того, если имя модуля имеет дефис,
его суффикс после первого дефиса удаляется (дефис тоже удаляется).
Например, если имя модуля <code>a.b.c-v2.1</code>,
имя функции будет <code>luaopen_a_b_c</code>.

<p>
Четвертый искатель пробует <em>все в одном загрузчик</em>.
Он ищет C&nbsp;путь для библиотеки с корневым путем переданного модуля.
Например, когда требуется <code>a.b.c</code>,
он будет искать C&nbsp;библиотеку <code>a</code>.
Если существует, он заглянет в нее для открытия функции подмодуля;
в нашем примере, это будет <code>luaopen_a_b_c</code>.
С этой возможностью, пакет может упаковывать различные C&nbsp;подмодули
в одной библиотеке, где
каждый подмодуль имеет свою оригинальную функцию открытия.

<p>
Все искатели, за исключением первого (preload),
возвращают имя файла, где найден модуль, как дополнительное значение,
возвращаемое <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.
Первый искатель не возвращает дополнительное значение.


<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>

<p>
Ищет имя <code>name</code> в пути <code>path</code>.

<p>
Путь - это строка, содержащая последовательность <em>шаблонов</em>,
разделенных точкой с запятой (;).
Для каждого шаблона, функция заменяет каждый знак вопроса (если существует)
копией <code>name</code>,
где все случаи <code>sep</code> (точка, по умолчанию)
заменяются на <code>rep</code> (системный разделитель директорий, по умолчанию),
и пытается открыть результирующее имя файла.

<p>
Например, если путь это строка

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
поиск имени <code>foo.a</code> будет пытаться открыть файлы
<code>./foo/a.lua</code>, <code>./foo/a.lc</code> и
<code>/usr/local/foo/a/init.lua</code>, в этом порядке.

<p>
Возвращает результирующее имя первого файла, который можно открыть в
режиме чтения (после закрытия файла),
или <b>nil</b> и сообщение об ошибке, если ничего не удалось.
(Это сообщение об ошибке перечисляет все имена файлов, которые
пыталась открыть функция.)



<h2>6.4 &ndash; <a name="6.4">Работа со строками</a></h2>

<p>
Эта библиотека предоставляет общие функции для работы со строками,
такие как поиск, извлечение подстрок и сопоставление шаблонов.
Когда индексируются строки в Lua, первый символ находится на позиции&nbsp;1
(не на&nbsp;0, как в C).
Допускаются негативные индексы, они интерпретируются как
индексирование обратно (задом наперед), с конца строки.
Таким образом, последний символ находится на позиции -1 и так далее.

<p>
Строковая библиотека предоставляет все свои функции в таблице
<a name="pdf-string"><code>string</code></a>.
Она также устанавливает метатаблицу для строк,
где поле <code>__index</code> указывает на таблицу <code>string</code>.
Следовательно, вы можете использовать строковые функции в объектно-ориентированном стиле.
Например, выражение <code>string.byte(s,i)</code>
может быть записано как <code>s:byte(i)</code>.

<p>
Строковая библиотека предполагает кодирование символов одним байтом.


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
Возвращает внутренние цифровые коды символов <code>s[i]</code>,
<code>s[i+1]</code>, ..., <code>s[j]</code>.
По умолчанию <code>i</code>&nbsp;=&nbsp;1; <code>j</code>&nbsp;=&nbsp;<code>i</code>.
Эти индексы следуют тем же правилам, что и в функции
<a href="#pdf-string.sub"><code>string.sub</code></a>.

<p>
Цифровые коды не обязательно портабельны между платформами.


<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
Получает ноль или более целых.
Возвращает строку длиной равной количеству аргументов,
в которой каждый символ имеет внутренний цифровой код равный
соответствующему аргументу.

<p>
Цифровые коды не обязательно портабельны между платформами.


<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>

<p>
Возвращает строку содержащую бинарное представление
(<em>бинарный кусок</em>) переданной функции,
так что <a href="#pdf-load"><code>load</code></a>
для этой строки возвращает копию функции (но с новыми upvalue).
Если <code>strip</code> = true,
бинарное представление может не включать всю отладочную информацию о функции,
для уменьшения размера.

<p>
Функции с upvalue сохраняют только количество upvalue.
При загрузке, эти upvalue получают свежие экземпляры, содержащие <b>nil</b>.
(Вы можете использовать отладочную библиотеку, чтобы сохранить и перезагрузить
upvalue функции в том виде, как вам нужно.)


<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>

<p>
Ищет первое совпадение шаблона <code>pattern</code> (см. <a href="#6.4.1">&sect;6.4.1</a>)
в строке <code>s</code>.
Если совпадение найдено, то <code>find</code> возвращает индексы&nbsp;<code>s</code>,
где совпадение начинается и заканчивается;
иначе, возвращает <b>nil</b>.
Третий опциональный цифровой аргумент <code>init</code> определяет,
где начинать поиск;
по умолчанию он равен&nbsp;1 и может быть отрицательным.
Значение <b>true</b> в качестве четвертого опционального аргумента <code>plain</code>
выключает возможности поиска шаблонов,
так функция выполняет плоский поиск подстроки,
без магических символов в <code>pattern</code>.
Учтите, что если передан <code>plain</code>,
то должен быть передан и <code>init</code>.

<p>
Если шаблон имеет захваты (capture), то при успешном совпадении
захваченные значения также возвращаются, после двух индексов.


<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>

<p>
Возвращает форматированную версию переменного количества аргументов,
следуя описанию в первом аргументе (должен быть строкой).
formatstring - следует тем же правилам, что и в функции <code>sprintf</code>
в ISO&nbsp;C.
Только отличается тем, что опции/модификаторы
<code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>
и <code>p</code> не поддерживаются,
и тем, что имеет дополнительную опцию <code>q</code>.
Опция <code>q</code> форматирует строку между двойными кавычками и
использует управляющие символы, когда необходимо гарантировать,
что строка может быть прочитана Lua интерпретатором обратно.
Например, вызов

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
может выдать строку:

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
Опции
<code>A</code>, <code>a</code>, <code>E</code>, <code>e</code>, <code>f</code>,
<code>G</code> и <code>g</code> - все ожидают цифровой аргумент.
Оции <code>c</code>, <code>d</code>,
<code>i</code>, <code>o</code>, <code>u</code>, <code>X</code> и <code>x</code> -
ожидают целое.
Опция <code>q</code> - ожидает строку.
Опция <code>s</code> - ожидает строку без встроенных нулей;
если аргумент не строка,
он конвертируется следуя тем же правилам, что и в <a href="#pdf-tostring"><code>tostring</code></a>.

<p>
Когда Lua скомпилирована с не C99 компилятором,
опции <code>A</code> и <code>a</code> (шестнадцатиричные вещественные числа)
не поддерживают модификаторы (флаги, ширина, длина).


<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
Возвращает функцию-итератор, которая при каждом вызове возвращает
следующие захваченные значения из <code>pattern</code> (см. <a href="#6.4.1">&sect;6.4.1</a>)
по строке <code>s</code>.
Если <code>pattern</code> не определяет захватов,
то в каждом вызове возвращается целое совпадение.

<p>
Например, следующий цикл будет перебирать все слова из строки <code>s</code>,
печатая по одному в строке:

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
Следующий пример собирает в таблице все пары <code>key=value</code> из строки:

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
Для этой функции, символ '<code>^</code>' в начале шаблона не работает как якорь,
т.к. это мешает итерации.


<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
Возвращает копию <code>s</code>, в которой все
(или первые <code>n</code>, если передано)
совпадения шаблона <code>pattern</code> (см. <a href="#6.4.1">&sect;6.4.1</a>)
заменены на замещающую строку, определенную параметром <code>repl</code>,
который может быть строкой, таблицей или функцией.
<code>gsub</code> также возвращает общее число совпадений, как второе значение.
Имя <code>gsub</code> происходит от <em>Global SUBstitution</em> (глобальная подстановка).

<p>
Если <code>repl</code> это строка, то её значение используется для замены.
Символ&nbsp;<code>%</code> работает, как управляющий символ:
любая последовательность в <code>repl</code> в виде <code>%<em>d</em></code>,
с <em>d</em> между 1 и 9, соответствует <em>d</em>-ой захваченной подстроке.
Последовательность <code>%0</code> соответствует полному совпадению.
Последовательность <code>%%</code> соответствует одному символу&nbsp;<code>%</code>.

<p>
Если <code>repl</code> это таблица, то таблица запрашивается для каждого совпадения,
используя первое захваченное значение, как ключ.

<p>
Если <code>repl</code> это функция, то эта функция вызывается для каждого совпадения,
все захваченные подстроки передаются в качестве аргументов, по порядку.

<p>
В любом случае, если шаблон не имеет захватов,
то он ведет себя так, будто весь шаблон находится в захвате.

<p>
Если значение, возвращенное из табличного запроса или из функции,
это строка или число, то оно используется, как замещающая строка;
иначе, если это <b>false</b> или <b>nil</b>,
то замена не производится
(т.е. оригинальное содержимое совпадения сохраняется в строке).

<p>
Несколько примеров:

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>


<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
Получает строку и возвращает её длину.
Пустая строка <code>""</code> имеет длину 0.
Встроенные нули считаются, так <code>"a\000bc\000"</code> имеет длину 5.


<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
Получает строку и возвращает её копию с заменой всех символов в верхнем регистре
на символы в нижнем регистре.
Остальные символы не изменяются.
Определение какие символы в верхнем регистре зависит от текущей локали.


<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
Ищет первое <em>совпадение</em> шаблона
<code>pattern</code> (см. <a href="#6.4.1">&sect;6.4.1</a>) в строке <code>s</code>.
Если находит, то <code>match</code> возвращает захваченные значения из шаблона;
иначе возвращает <b>nil</b>.
Если <code>pattern</code> не описывает захватов,
то возвращается целое совпадение.
Третий опциональный цифровой аргумент <code>init</code> определяет,
где начинать поиск;
по умолчанию он равен&nbsp;1, и может быть отрицательным.


<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>

<p>
Возвращает бинарную строку, содержащую значения <code>v1</code>, <code>v2</code> и т.д.
упакованными (т.е. записанными в бинарной форме)
согласно форматной строке <code>fmt</code> (см. <a href="#6.4.2">&sect;6.4.2</a>).


<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>

<p>
Возвращает размер результирующей строки из <a href="#pdf-string.pack"><code>string.pack</code></a>
с переданным форматом.
Форматная строка не может иметь опций переменной длины
'<code>s</code>' или '<code>z</code>' (см. <a href="#6.4.2">&sect;6.4.2</a>).


<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
Возвращает строку, которая состоит из слияния <code>n</code> копий строки
<code>s</code>, разделенных строкой <code>sep</code>.
Значение по умолчанию для <code>sep</code> это пустая строка
(т.е. нет разделителя).
Возвращает пустую строку, если <code>n</code> отрицательное значение.


<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
Возвращает строку, в которой символы <code>s</code> идут в обратном порядке.


<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
Возвращает подстроку <code>s</code>, начинающуюся на <code>i</code>
и продолжающуюся до <code>j</code>;
<code>i</code> и <code>j</code> могут быть отрицательными.
Если <code>j</code> отсутствует, то он подразумевается равным -1
(тоже что и длина строки).
В частности, вызов <code>string.sub(s,1,j)</code> возвращает префикс <code>s</code>
длиной <code>j</code>, и <code>string.sub(s, -i)</code>
возвращает суффикс <code>s</code> длиной <code>i</code>.

<p>
Если после трансляции отрицательных индексов
<code>i</code> < 1, он корректируется до 1.
Если <code>j</code> больше длины строки, он корректируется до этой длины.
Если после этих преобразований
<code>i</code> > <code>j</code>, функция возвращает пустую строку.


<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>

<p>
Возвращает значения, упакованные в строке <code>s</code>
(см. <a href="#pdf-string.pack"><code>string.pack</code></a>)
согласно форматной строке <code>fmt</code> (см. <a href="#6.4.2">&sect;6.4.2</a>).
Опциональный параметр <code>pos</code> отмечает,
где начинать чтение в <code>s</code> (по умолчанию 1).
После чтения значений, эта функция также возвращает индекс
первого не прочитанного байта в <code>s</code>.


<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
Получает строку и возвращает её копию с заменой всех символов в нижнем регистре
на символы в верхнем регистре.
Остальные символы не изменяются.
Определение какие символы в нижнем регистре зависит от текущей локали.



<h3>6.4.1 &ndash; <a name="6.4.1">Шаблоны</a></h3>

<p>
Шаблоны в Lua описываются регулярными строками,
которые интерпретируются, как шаблоны, функциями сопоставления шаблонов
<a href="#pdf-string.find"><code>string.find</code></a>,
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>,
<a href="#pdf-string.gsub"><code>string.gsub</code></a>
и <a href="#pdf-string.match"><code>string.match</code></a>.
Этот раздел описывает синтаксис и значение (сопоставление)
этих строк.


<h4>Символьный класс:</h4><p>
<em>Символьный класс</em> используется для представления набора символов.
В описании символьного класса допустимы следующие комбинации:

<ul>

<li><b><em>x</em>: </b>
(где <em>x</em> - не один из <em>магических символов</em>
<code>^$()%.[]*+-?</code>)
представляет символ <em>x</em> непосредственно.
</li>

<li><b><code>.</code>: </b> (точка) представляет все символы.</li>
<li><b><code>%a</code>: </b> представляет все буквы.</li>
<li><b><code>%c</code>: </b> представляет все управляющие символы.</li>
<li><b><code>%d</code>: </b> представляет все цифры.</li>
<li><b><code>%g</code>: </b> представляет все печатаемые символы, кроме пробела.</li>
<li><b><code>%l</code>: </b> представляет все буквы в нижнем регистре.</li>
<li><b><code>%p</code>: </b> представляет все знаки пунктуации.</li>
<li><b><code>%s</code>: </b> представляет все пробельные символы.</li>
<li><b><code>%u</code>: </b> представляет все буквы в верхнем регистре.</li>
<li><b><code>%w</code>: </b> представляет все алфавитно-цифровые символы.</li>
<li><b><code>%x</code>: </b> представляет все шестнадцатиричные символы.</li>
<li><b><code>%<em>x</em></code>: </b> (где <em>x</em> - не алфавитно-цифровой символ)
представляет символ <em>x</em>.
Это стандартный способ кодирования магических символов.
Любой не алфавитно-цифровой символ
(включая все знаки пунктуации, даже не магические)
могут предваряться '<code>%</code>',
когда используются для представления себя в шаблоне.
</li>

<li><b><code>[<em>набор</em>]</code>: </b>
представляет класс, который является объединением всех символов в <em>наборе</em>.
Диапазон символов может быть определен отделением конечного символа диапазона,
в восходящем порядке, символом '<code>-</code>'.
Все классы <code>%</code><em>x</em>, описанные выше,
также могут быть включены в <em>набор</em>, как компоненты.
Все остальные символы в <em>наборе</em> представляют непосредственно себя.
Например, <code>[%w_]</code> (или <code>[_%w]</code>)
представляет все алфавитно-цифровые символы и подчеркивание,
<code>[0-7]</code> представляет восьмиричные цифры,
<code>[0-7%l%-]</code> представляет восьмиричные цифры,
буквы в нижнем регистре и символ '<code>-</code>'.

<p>
Взаимодействие между диапазонами и классами не определено.
Следовательно, шаблоны как <code>[%a-z]</code> или <code>[a-%%]</code>
не имеют значения.
</li>

<li><b><code>[^<em>набор</em>]</code>: </b>
представляет отрицание <em>набора</em>,
где <em>набор</em> интерпретируется, как описано выше.
</li>

</ul><p>
Для всех классов, представленных одним символом (<code>%a</code>, <code>%c</code> и др.),
соответствующие представления с буквой в верхнем регистре отрицают класс.
Например, <code>%S</code> представляет все не пробельные символы.

<p>
Определения букв, пробелов и других групп символов
зависят от текущей локали.
В частности, класс <code>[a-z]</code> может не быть эквивалентом <code>%l</code>.


<h4>Элемент шаблона:</h4><p>
<em>элементом шаблона</em> может быть

<ul>

<li>
односимвольный класс,
который соответствует одному символу в классе;
</li>

<li>
односимвольный класс с последующим символом '<code>*</code>',
который соответствует нулю или более повторам символов в классе.
Этот повтор элементов всегда будет соответствовать
самой длинной возможной последовательности;
</li>

<li>
односимвольный класс с последующим символом '<code>+</code>',
который соответствует одному или более повторам символов в классе.
Этот повтор элементов всегда будет соответствовать
самой длинной возможной последовательности;
</li>

<li>
односимвольный класс с последующим символом '<code>-</code>',
который соответствует нулю или более повторам символов в классе.
В отличие от '<code>*</code>',
этот повтор элементов всегда будет соответствовать самой короткой
возможной последовательности;
</li>

<li>
односимвольный класс с последующим символом '<code>?</code>',
который соответствует нулю или одному случаю символа в классе.
Он всегда соответсвует одному вхождению, если возможно;
</li>

<li>
<code>%<em>n</em></code>, для <em>n</em> между 1 и 9;
этот элемент соответствует подстроке равной <em>n</em>-й захваченной строке
(см. ниже);
</li>

<li>
<code>%b<em>xy</em></code>, где <em>x</em> и <em>y</em> два четких символа;
этот элемент соответствует строкам, которые начинаются с &nbsp;<em>x</em>
и заканчиваются на &nbsp;<em>y</em>,
и где <em>x</em> и <em>y</em> <em>сбалансированы</em>.
Это значит, что если при чтении строки слева направо,
считать <em>+1</em> для <em>x</em> и <em>-1</em> для <em>y</em>,
завершающий <em>y</em> это первый <em>y</em>, где счет достигнет 0.
Например, элемент <code>%b()</code> соответсвует выражениям в
сбалансированных скобках.
</li>

<li>
<code>%f[<em>набор</em>]</code>, <em>граничный шаблон</em>;
этот элемент соответствует пустой строке в любой позиции такой,
что следующий символ принадлежит <em>набору</em>
и предыдущий символ не принадлежит <em>набору</em>.
<em>Набор</em> интерпретируется, как описано выше.
Начало и конец субъекта обрабатывается, как если там символ '<code>\0</code>'.
</li>

</ul>


<h4>Шаблон:</h4><p>
<em>Шаблон</em> - это последовательность элементов шаблона.
Символ '<code>^</code>' в начале шаблона фиксирует его в начале строки.
Символ '<code>$</code>' в конце шаблона фиксирует его в конце строки.
В остальных позициях '<code>^</code>' и '<code>$</code>'
не имеют специального значения и представляют сами себя.


<h4>Захваты (capture):</h4><p>
Шаблон может содержать подшаблоны заключенные в скобки;
они описывают <em>захваты</em>.
Когда совпадение успешно, подстроки,
которые соответсвуют захватам (<em>захваченные</em>),
сохраняются для последующего использования.
Захваты нумеруются соответственно их левым скобкам.
Например, в шаблоне <code>"(a*(.)%w(%s*))"</code>,
часть строки, соответствующая <code>"a*(.)%w(%s*)"</code>,
сохраняется как первый захват (и следовательно имеет номер&nbsp;1);
соответствие "<code>.</code>" захватывается с номером&nbsp;2,
и часть соответствующая "<code>%s*</code>" имеет номер&nbsp;3.

<p>
Специальный случай, пустой захват <code>()</code> захватывает
текущую позицию в строке (число).
Например, если мы применим шаблон <code>"()aa()"</code> к строке
<code>"flaaap"</code>, будет сделано два захвата: 3&nbsp;и&nbsp;5.



<h3>6.4.2 &ndash; <a name="6.4.2">Формат строк для string.pack и string.unpack</a></h3>

<p>
Первый аргумент в <a href="#pdf-string.pack"><code>string.pack</code></a>,
<a href="#pdf-string.packsize"><code>string.packsize</code></a> и
<a href="#pdf-string.unpack"><code>string.unpack</code></a>
это строка формата,
которая описывает формат создаваемой или читаемой структуры.

<p>
Строка формата - это последовательность опций преобразования.
Опции преобразования следующие:

<ul>
<li><b><code>&lt;</code>: </b>устанавливает прямой порядок байт (little endian)</li>
<li><b><code>&gt;</code>: </b>устанавливает обратный порядок байт (big endian)</li>
<li><b><code>=</code>: </b>устанавливает исконный порядок байт</li>
<li><b><code>![<em>n</em>]</code>: </b>устанавливает максимальное выравнивание равным <code>n</code>
(по умолчанию, исконное выравнивание)</li>
<li><b><code>b</code>: </b>знаковый байт (<code>char</code>)</li>
<li><b><code>B</code>: </b>беззнаковый байт (<code>char</code>)</li>
<li><b><code>h</code>: </b>знаковый <code>short</code> (исконный размер)</li>
<li><b><code>H</code>: </b>беззнаковый <code>short</code> (исконный размер)</li>
<li><b><code>l</code>: </b>знаковый <code>long</code> (исконный размер)</li>
<li><b><code>L</code>: </b>беззнаковый <code>long</code> (исконный размер)</li>
<li><b><code>j</code>: </b><code>lua_Integer</code></li>
<li><b><code>J</code>: </b><code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b><code>size_t</code> (исконный размер)</li>
<li><b><code>i[<em>n</em>]</code>: </b>знаковый <code>int</code> с <code>n</code> байт
(по умолчанию, исконный размер)</li>
<li><b><code>I[<em>n</em>]</code>: </b>беззнаковый <code>int</code> с <code>n</code> байт
(по умолчанию, исконный размер)</li>
<li><b><code>f</code>: </b><code>float</code> (исконный размер)</li>
<li><b><code>d</code>: </b><code>double</code> (исконный размер)</li>
<li><b><code>n</code>: </b><code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b>строка фиксированного размера с <code>n</code> байт</li>
<li><b><code>z</code>: </b>завершаемая нулем строка</li>
<li><b><code>s[<em>n</em>]</code>: </b>строка с предваряющим её размером, кодированным
как беззнаковое целое с <code>n</code> байт
(по умолчанию, это <code>size_t</code>)</li>
<li><b><code>x</code>: </b>один байт заполнения</li>
<li><b><code>X<em>op</em></code>: </b>пустой элемент, который выравнивает в соответствии с
опцией <code>op</code> (которая в противном случае игнорируется)</li>
<li><b>'<code> </code>': </b>(пустое пространство) игнорируется</li>
</ul><p>
("<code>[<em>n</em>]</code>" означает опциональную целую цифру.)
Кроме заполнения, пробелов и конфигураций
(опции "<code>xX &lt;=&gt;!</code>"),
каждая опция соответствует аргументу (в <a href="#pdf-string.pack"><code>string.pack</code></a>)
или результату (в <a href="#pdf-string.unpack"><code>string.unpack</code></a>).

<p>
Для опций "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>" и "<code>I<em>n</em></code>",
<code>n</code> может быть целым от 1 до 16.
Все целые опции проверяют переполнения;
<a href="#pdf-string.pack"><code>string.pack</code></a> проверяет,
что переданное значение поместится в переданный размер;
<a href="#pdf-string.unpack"><code>string.unpack</code></a> проверяет,
что прочитанное значение поместится в целое Lua.

<p>
Любая строка формата начинается так, будто содержит префикс "<code>!1=</code>",
т.е. с максимальным выравниванием 1 (без выравнивания)
и исконным порядком байт.

<p>
Выравнивание работает так:
для каждой опции формат получает дополнительное заполнение,
пока не начнутся данные по смещению, которое равно произведению
минимума между размером опции и максимального выравнивания;
этот минимум должен быть степенью 2.
Опции "<code>c</code>" и "<code>z</code>" не выравниваются;
опция "<code>s</code>" следует выравниванию её начального целого.

<p>
Все заполнения заполняются нулями в <a href="#pdf-string.pack"><code>string.pack</code></a>
(и игнорируются в <a href="#pdf-string.unpack"><code>string.unpack</code></a>).



<h2>6.5 &ndash; <a name="6.5">Поддержка UTF-8</a></h2>

<p>
Эта библиотека предоставляет базовую поддержку для кодировки UTF-8.
Она предоставляет все свои функции в таблице <a name="pdf-utf8"><code>utf8</code></a>.
Эта библиотека не предоставляет другой поддержки для Unicode,
кроме обработки кодировки.
Все операции, нуждающиеся в значении символа,
такие как классификация символов, не входят в эту область.

<p>
Пока не установлено иначе,
все функции, которые ожидают позицию байта, как параметр,
предполагают, что переданная позиция является также началом последовательности байт
или позиция плюс длина строки.
Как и в строковой библиотеке,
отрицательные индексы отсчитываются с конца строки.


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
Получает ноль или более целых,
конвертирует каждое из них в соответствующую последовательность байт UTF-8
и возвращает строку со слиянием всех этих последовательностей.


<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
Шаблон (строка, не функция) "<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
(см. <a href="#6.4.1">&sect;6.4.1</a>),
который соответствует точно одной последовательности байт UTF-8,
предполагается, что субъект это правильная UTF-8 строка.


<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>

<p>
Возвращает значения такие, что конструкция

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
будет перебирать все символы в строке <code>s</code>,
где <code>p</code> - позиция (в байтах) и
<code>c</code> - кодовая точка для каждого символа.

Функция вызывает ошибку, если встретит неправильную последовательность байт.


<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
Возвращает кодовые точки (как целые) для всех символов в <code>s</code>,
начиная с байта на позиции <code>i</code> и заканчивая <code>j</code> (включительно).
По умолчанию, <code>i</code> = 1 и <code>j</code> = <code>i</code>.
Функция вызывает ошибку, если встретит неправильную последовательность байт.


<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
Возвращает количество символов UTF-8 в строке <code>s</code>,
начиная с байта на позиции <code>i</code> и заканчивая <code>j</code> (включительно).
По умолчанию, <code>i</code> = 1 и <code>j</code> = -1.
Если функция встречает неправильную последовательность байт,
она возвращает false и позицию первой неправильной последовательности байт.


<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
Возвращает позицию (в байтах), где начинается <code>n</code>-й
закодированный символ строки <code>s</code>
(счет идет с позиции <code>i</code>).
При отрицательном значении <code>n</code>, получает символы перед позицией <code>i</code>.
По умолчанию, <code>i</code> = 1, когда <code>n</code> положительное значение,
и <code>i = #s + 1</code> иначе,
так <code>utf8.offset(s, -n)</code> получает смещение
<code>n</code>-го символа с конца строки.
Если определенный символ ни в субъекте, ни справа после его конца,
функция возвращает <b>nil</b>.

<p>
Специальный случай, когда <code>n</code> = 0,
функция возвращает начало закодированного символа,
который содержит <code>i</code>-й байт строки <code>s</code>.

<p>
Эта функция предполагает, что <code>s</code> это правильная строка UTF-8.



<h2>6.6 &ndash; <a name="6.6">Работа с таблицами</a></h2>

<p>
Эта библиотека предоставляет базовые функции для работы с таблицами.
Она предоставляет все свои функции в таблице <a name="pdf-table"><code>table</code></a>.

<p>
Помните, что когда операция нуждается в длине таблицы,
таблица должа содержать соответсвующую последовательность
или иметь метаметод <code>__len</code> (см. <a href="#3.4.7">&sect;3.4.7</a>).
Все функции игнорируют не цифровые ключи
в таблицах, полученных как аргументы.


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>

<p>
Получает список list, где все элементы строки или числа,
возвращает строку <code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>.
По умолчанию, <code>sep</code> это пустая строка, <code>i</code> = 1
и <code>j</code> = <code>#list</code>.
Если <code>i</code> > <code>j</code>, возвращает пустую строку.


<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>

<p>
Вставляет элемент <code>value</code> на позицию <code>pos</code> в список <code>list</code>,
сдвигая элементы вверх
<code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code>.
По умолчанию, <code>pos</code> = <code>#list+1</code>,
так вызов <code>table.insert(t,x)</code> вставляет <code>x</code>
в конец списка <code>t</code>.


<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>

<p>
Перемещает элементы из таблицы <code>a1</code> в таблицу <code>a2</code>.
Эта функция эквивалентна множественному присваиванию:
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>.
По умолчанию, <code>a2</code> = <code>a1</code>.
Целевой диапазон может перекрываться с диапазоном источником.
Количество элементов для перемещения должно помещаться в целое Lua.


<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>

<p>
Возвращает новую таблицу, в которой все параметры сохранены с ключами 1, 2 и т.д.
и поле "<code>n</code>" содержит количество параметров.
Учтите, что результирующая таблица может не быть последовательностью.


<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>

<p>
Удаляет из списка <code>list</code> элемент на позиции <code>pos</code>,
возвращая значение этого элемента.
Когда <code>pos</code> это целое между 1 и <code>#list</code>,
функция сдвигает элементы вниз
<code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
и стирает элемент <code>list[#list]</code>;
Индекс <code>pos</code> может быть 0, когда <code>#list</code> = 0,
или <code>#list + 1</code>;
в этих случаях функция стирает элемент <code>list[pos]</code>.

<p>
По умолчанию, <code>pos</code> = <code>#list</code>,
так вызов <code>table.remove(l)</code> удаляет последний элемент
списка <code>l</code>.


<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>

<p>
Сортирует элементы полученного списка, <em>на месте</em>,
от <code>list[1]</code> до <code>list[#list]</code>.
Если передан параметр <code>comp</code>,
он должен быть функцией, которая получает два элемента списка и
возвращает true, когда первый элемент должен находиться перед вторым
в финальном упорядочении
(так выражение <code>not comp(list[i+1],list[i])</code> будет истинным после сортировки).
Если параметр <code>comp</code> не передан,
то взамен Lua использует стандартный оператор <code>&lt;</code>.

<p>
Алгоритм сортировки не стабилен;
т.е. элементы, считающиеся равными в этом упорядочении,
в результате сортировки могут изменить свои относительные позиции.


<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>

<p>
Возвращает элементы из полученного списка.
Эта функция эквивалентна

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
По умолчанию, <code>i</code> =&nbsp;1 и <code>j</code> = <code>#list</code>.


<h2>6.7 &ndash; <a name="6.7">Математические функции</a></h2>

<p>
Эта библиотека предоставляет базовые математические функции.
Она предоставляет все свои функции и константы в таблице <a name="pdf-math"><code>math</code></a>.
Функции с комментарием "<code>integer/float</code>"
выдают целые результаты для целых аргументов
и вещественные результаты для вещественных (или смешанных) аргументов.
Функции округления
(<a href="#pdf-math.ceil"><code>math.ceil</code></a>,
<a href="#pdf-math.floor"><code>math.floor</code></a>
и <a href="#pdf-math.modf"><code>math.modf</code></a>)
возвращают целое, когда результат помещается в диапазон целых,
или вещественное иначе.


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>
<p>
Возвращает абсолютное значение <code>x</code>. (integer/float)


<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>
<p>
Возвращает арккосинус <code>x</code> (в радианах).


<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>
<p>
Возвращает арксинус <code>x</code> (в радианах).


<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>
<p>
Возвращает арктангенс <code>y/x</code> (в радианах),
но использует знаки обоих параметров для поиска квадранта результата.
(Также корректно обрабатывает случай, когда <code>x</code> = 0.)

<p>
По умолчанию <code>x</code> = 1,
так вызов <code>math.atan(y)</code>
возвращает арктангенс <code>y</code>.


<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>
<p>
Возвращает наименьшее целое значение, которое больше или равно <code>x</code>.


<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>
<p>
Возвращает косинус <code>x</code> (в радианах).


<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>
<p>
Преобразует угол <code>x</code> из радиан в градусы.


<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>
<p>
Возвращает значение <em>e<sup>x</sup></em>
(где <code>e</code> - основание натурального логарифма).


<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>
<p>
Возвращает наибольшее значение, которое меньше или равно <code>x</code>.


<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>
<p>
Возвращает остаток от деления <code>x</code> на <code>y</code>,
который округляет частное к нулю. (integer/float)


<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>
<p>
Вещественное значение <code>HUGE_VAL</code>,
которое больше любого другого числового значения.


<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>
<p>
Возвращает логарифм <code>x</code> по основанию <code>base</code>.
По умолчанию, <code>base</code> = <em>e</em>
(так функция возвращает натуральный логарифм <code>x</code>).


<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>
<p>
Возвращает аргумент с максимальным значением,
в соответствии с Lua оператором <code>&lt;</code>. (integer/float)


<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
Целое с максимальным значением для целого.


<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>
<p>
Возвращает аргумент с минимальным значением,
в соответствии с Lua оператором <code>&lt;</code>. (integer/float)


<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
Целое с минимальным значением для целого.


<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>
<p>
Возвращает целую и дробную часть <code>x</code>.
Второй результат всегда вещественное число.


<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>
<p>
Значение <em>&pi;</em>.


<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>
<p>
Преобразует угол <code>x</code> из градусов в радианы.


<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>
<p>
Когда вызвана без аргументов,
возвращает псевдослучайное вещественное число с однородным распределением
в диапазоне <em>[0,1)</em>.  
Когда вызвана с двумя целыми <code>m</code> и <code>n</code>,
<code>math.random</code> возвращает псевдослучайное целое
с однородным распределением в диапазоне <em>[m, n]</em>.
(Значение <em>m-n</em> не может быть отрицательным и должно помещаться в целое Lua.)
Вызов <code>math.random(n)</code> эквивалентен вызову <code>math.random(1,n)</code>.

<p>
Эта функция является интерфейсом к генератору псевдослучайных чисел,
предоставляемому  C.
Нет гарантий для его статистических свойств.


<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>
<p>
Устанавливает <code>x</code> как "затравку" (seed)
для генератора псевдослучайных чисел:
одинаковые затравки производят одинаковые последовательности чисел.


<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>
<p>
Возвращает синус <code>x</code> (в радианах).


<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>
<p>
Возвращает квадратный корень <code>x</code>.
(Для вычисления этого значения вы также можете использовать выражение <code>x^0.5</code>.)


<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>
<p>
Возвращает тангенс <code>x</code> (в радианах).


<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>
<p>
Если значение <code>x</code> можно преобразовать в целое,
возвращает целое.
Иначе, возвращает <b>nil</b>.


<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>
<p>
Возвращает "<code>integer</code>" - если <code>x</code> целое,
"<code>float</code>" - если <code>x</code> вещественное,
или <b>nil</b> - если <code>x</code> не число.


<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>
<p>
Возвращает логическое значение,
true, если целое <code>m</code> ниже целого <code>n</code>,
когда они сравниваются как беззнаковые целые.


<h2>6.8 &ndash; <a name="6.8">Средства ввода-вывода</a></h2>

<p>
Библиотека ввода-вывода предоставляет два разных стиля для файловых манипуляций.
Первый использует подразумевающиеся описатели файлов (handle);
т.е. там есть операции установки файла ввода и файла вывода по умолчанию,
и все операции ввода-вывода используют эти файлы.
Второй стиль использует явные описатели файлов.

<p>
При использовании неявных описателей файлов,
все операции предоставляются в таблице <a name="pdf-io"><code>io</code></a>.
При использовании явных описателей,
операция <a href="#pdf-io.open"><code>io.open</code></a> возвращает описатель файла
и затем все операции предоставляются, как методы этого описателя.

<p>
Таблица <code>io</code> также предоставляет
три предопределенных файловых описателя с обычными значениями из C:
<a name="pdf-io.stdin"><code>io.stdin</code></a>,
<a name="pdf-io.stdout"><code>io.stdout</code></a> и
<a name="pdf-io.stderr"><code>io.stderr</code></a>.
Библиотека ввода-вывода никогда не закрывает эти файлы.

<p>
Пока не установлено иначе,
все функции ввода-вывода возвращают <b>nil</b> при ошибке
(и сообщение об ошибке, как второй результат, и зависящий от системы
код ошибки, как третий)
и отличное от <b>nil</b> значение при успехе.
На не POSIX системах,
формирование сообщения об ошибке и кода ошибки может не быть потокобезопасным,
т.к. они полагаются на глобальную C переменную <code>errno</code>.


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>
<p>
Эквивалентно <code>file:close()</code>.
Без <code>file</code>, закрывает выходной файл по умолчанию.


<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>
<p>
Эквивалентно <code>io.output():flush()</code>.


<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>
<p>
Когда вызвана с именем файла, открывает данный файл (в текстовом режиме),
и устанавливает его описатель, как файл ввода по умолчанию.
Когда вызвана с описателем файла,
просто устанавливает этот описатель, как файл ввода по умолчанию
Когда вызвана без параметров,
возвращает текущий файл ввода по умолчанию.

<p>
В случае ошибок эта функция генерирует ошибку,
вместо возвращения кода ошибки.


<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename &middot;&middot;&middot;])</code></a></h3>

<p>
Открывает переданный файл в режиме чтения
и возвращает функцию итератор,
которая работает подобно <code>file:lines(&middot;&middot;&middot;)</code> для открытого файла.
Когда итератор доходит до конца файла,
он ничего не возвращает (для завершения цикла)
и автоматически закрывает файл.

<p>
Вызов <code>io.lines()</code> (без имени файла) эквивалентно
<code>io.input():lines("*l")</code>;
т.е. он перебирает линии файла ввода по умолчанию.
В этом случае он не закрывает файл при завершении цикла.

<p>
В случае ошибок эта функция генерирует ошибку,
вместо возвращения кода ошибки.


<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>

<p>
Функция открывает файл
в режиме, определяемым строкой <code>mode</code>.
Возвращает новый описатель файла,
или, в случае ошибок, возвращает <b>nil</b> и сообщение об ошибке.

<p>
Строка <code>mode</code> может быть следующей:

<ul>
<li><b>"<code>r</code>": </b> режим чтения (по умолчанию);</li>
<li><b>"<code>w</code>": </b> режим записи;</li>
<li><b>"<code>a</code>": </b> режим добавления;</li>
<li><b>"<code>r+</code>": </b> режим обновления, все предыдущие данные сохраняются;</li>
<li><b>"<code>w+</code>": </b> режим обновления, все предыдущие данные стираются;</li>
<li><b>"<code>a+</code>": </b> режим добавления и обновления, предыдущие данные сохраняются,
запись разрешена только в конец файла.</li>
</ul><p>
Строка <code>mode</code> также может содержать '<code>b</code>' в конце,
это нужно на некоторых системах для открытия файла в бинарном режиме.


<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>
<p>
Подобно <a href="#pdf-io.input"><code>io.input</code></a>,
но для файла вывода по умолчанию.


<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>
<p>
Эта функция зависит от системы и не доступна на некоторых платформах.

<p>
Запускает программу <code>prog</code> в отдельном процессе и возвращает
описатель файла, который вы можете использовать для чтения данных
из этой программы
(если <code>mode</code> = <code>"r"</code>, по умолчанию)
или для записи данных в программу
(если <code>mode</code> = <code>"w"</code>).


<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>
<p>
Эквивалентно <code>io.input():read(&middot;&middot;&middot;)</code>.


<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>
<p>
Возвращает описатель для временного файла.
Этот файл открывается в режиме обновления
и автоматически удаляется по завершении программы.


<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>
<p>
Проверяет, что независимый <code>obj</code> это правильный описатель файла.
Возвращает строку <code>"file"</code> - если <code>obj</code> открытый описатель файла,
<code>"closed file"</code> - если <code>obj</code> закрытый описатель файла,
или <b>nil</b> - если <code>obj</code> не является описателем файла.


<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>
<p>
Эквивалентно <code>io.output():write(&middot;&middot;&middot;)</code>.


<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>
<p>
Закрывает <code>file</code>.
Учтите, что файлы закрываются автоматически, когда их описатели
собраны сборщиком мусора,
но это может занять неопределенное количество времени.

<p>
Когда закрываемый описатель файла создан функцией <a href="#pdf-io.popen"><code>io.popen</code></a>,
<a href="#pdf-file:close"><code>file:close</code></a> возвращает те же значения,
что и <a href="#pdf-os.execute"><code>os.execute</code></a>.


<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>
<p>
Сохраняет все записанные данные в <code>file</code>.


<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>
<p>
Возвращает функцию итератор,
которая при каждом вызове читает файл в соответствии с переданными форматами.
Когда формат не передан,
использует "<code>l</code>", по умолчанию.
Например, конструкция

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
будет перебирать все символы файла,
начиная с текущей позиции.
В отличие от <a href="#pdf-io.lines"><code>io.lines</code></a>,
эта функция не закрывает файл после завершения цикла.

<p>
В случае ошибок эта функция генерирует ошибку,
вместо возвращения кода ошибки.


<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>

<p>
Читает файл <code>file</code>,
в соответствии с переданными форматами, которые определяют, что читать.
Для каждого формата,
функция возвращает строку или число с прочитанными символами,
или <b>nil</b>, если не может прочитать данные в этом формате.
(В этом последнем случае,
функция не читает последующие форматы.)
Когда вызвана без форматов,
использует по умолчанию формат, читающий следующую строку
(см. ниже).

<p>
Доступны следующие форматы

<ul>

<li><b>"<code>n</code>": </b>
читает число и возвращает его, как вещественное или целое,
следуя лексическим соглашениям Lua.
(Число может содержать начальные пробелы и знак.)
Этот формат всегда читает самую длинную входную последовательность,
которая является правильным префиксом для числа;
если префикс не правильный
(пустая строка, "<code>0x</code>" или "<code>3.4e-</code>"),
он отбрасывается и функция возвращает <b>nil</b>.
</li>

<li><b>"<code>a</code>": </b>
читает весь файл, начиная с текущей позиции.
В конце файла возвращает пустую строку.
</li>

<li><b>"<code>l</code>": </b>
читает следующую строку, пропуская символ конца строки,
возвращает <b>nil</b> в конце файла.
Это формат по умолчанию.
</li>

<li><b>"<code>L</code>": </b>
читает следующую строку, сохраняя символ конца строки (если есть),
возвращает <b>nil</b> в конце файла.
</li>

<li><b><em>число</em>: </b>
читает строку этой длины в байтах,
возвращает <b>nil</b> в конце файла.
Если <code>number</code> = 0,
ничего не читает и возвращает пустую строку,
или <b>nil</b> в конце файла.
</li>

</ul><p>
Форматы "<code>l</code>" и "<code>L</code>"
должны использоваться только для текстовых файлов.


<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>

<p>
Устанавливает и возвращает позицию в файле,
измеряемую от начала файла до позиции переданной в <code>offset</code>
плюс база, определенная строкой <code>whence</code>:

<ul>
<li><b>"<code>set</code>": </b> база на позиции 0 (начало файла);</li>
<li><b>"<code>cur</code>": </b> база на текущей позиции;</li>
<li><b>"<code>end</code>": </b> база в конце файла;</li>
</ul><p>
В случае успеха, <code>seek</code> возвращает окончательную позицию в файле,
измеряемую в байтах от начала файла.
При ошибке, возвращает <b>nil</b>
и сообщение об ошибке.

<p>
По умолчанию <code>whence</code> = <code>"cur"</code>, <code>offset</code> = 0.
Так вызов <code>file:seek()</code> возвращает текущую позицию, не изменяя её;
вызов <code>file:seek("set")</code> устанавливает позицию в начало файла
(и возвращает 0);
вызов <code>file:seek("end")</code> устанавливает позицию в конец файла
и возвращает размер файла.


<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>
<p>
Устанавливает режим буферизации для выходного файла.
Доступны три режима:

<ul>

<li><b>"<code>no</code>": </b>
без буферизации; результат любой операции вывода проявляется непосредственно.
</li>

<li><b>"<code>full</code>": </b>
полная буферизация; операция вывода выполняется только, когда буфер полон
или когда вы явно сбрасываете (flush) файл (см. <a href="#pdf-io.flush"><code>io.flush</code></a>).
</li>

<li><b>"<code>line</code>": </b>
строчная буферизация; выход буферизуется до новой строки в выводе
или до любого ввода из специальных файлов
(таких как терминал).
</li>

</ul><p>
Для двух последних случаев <code>size</code>
определяет размер буфера, в байтах.
По умолчанию это подходящий размер.


<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>

<p>
Записывает значение каждого аргумента в <code>file</code>.
Аргументы должны быть строками или числами.

<p>
В случае успеха функция возвращает <code>file</code>.
Иначе, возвращает <b>nil</b> и сообщение об ошибке.



<h2>6.9 &ndash; <a name="6.9">Средства операционной системы</a></h2>

<p>
Эта библиотека реализована через таблицу <a name="pdf-os"><code>os</code></a>.


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>

<p>
Возвращает апроксимацию количества секунд времени процессора,
использованного программой.


<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>

<p>
Возвращает строку или таблицу, содержащую дату и время,
отформатированную в соответствии с переданной строкой <code>format</code>.

<p>
Если аргумент <code>time</code> передан,
то он является временем для форматирования
(см. функцию <a href="#pdf-os.time"><code>os.time</code></a> для описания этого значения).
Иначе, <code>date</code> форматирует текущее время.

<p>
Если <code>format</code> начинается с символа '<code>!</code>',
то дата форматируется во всемирном координированном времени (UTC).
После этого опционального символа,
если <code>format</code> это строка "<code>*t</code>",
то <code>date</code> возвращает таблицу со следующими полями:
<code>year</code> - год (четыре цифры), <code>month</code> - месяц (1&ndash;12),
<code>day</code> - день (1&ndash;31),
<code>hour</code> - час (0&ndash;23), <code>min</code> - минута (0&ndash;59),
<code>sec</code> - секунда (0&ndash;61),
<code>wday</code> - день недели (воскресенье =&nbsp;1),
<code>yday</code> - день в году
и <code>isdst</code> - летнее время (boolean).
Это последнее поле может отсутствовать, если информация недоступна.

<p>
Если <code>format</code> не "<code>*t</code>",
то <code>date</code> возвращает дату как строку,
форматированную согласно правилам C функции <code>strftime</code>.

<p>
Когда вызвана без аргументов,
<code>date</code> возвращает разумное представление даты и времени,
зависящее от хостовой системы и текущей локали
(т.е. <code>os.date()</code> эквивалентно <code>os.date("%c")</code>).

<p>
На не POSIX системах
эта функция может не быть потокобезопасной,
т.к. она использует C&nbsp;функции <code>gmtime</code> и <code>localtime</code>.


<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>

<p>
Возвращает разницу, в секундах,
от времени <code>t1</code> до времени <code>t2</code>
(где значения времени возвращены <a href="#pdf-os.time"><code>os.time</code></a>).
В POSIX, Windows и некоторых других системах
это значение точно <code>t2</code><em>-</em><code>t1</code>.


<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>

<p>
Эта функция эквивалентна ISO&nbsp;C функции <code>system</code>.
Она передает <code>command</code> для запуска оболочкой операционной системы.
Её первый результат равен <b>true</b>,
если команда завершена успешно,
или <b>nil</b> иначе.
После этого первого результата
функция возвращает строку и число:

<ul>

<li><b>"<code>exit</code>": </b>
команда завершена нормально;
следующее число это выходной статус команды.
</li>

<li><b>"<code>signal</code>": </b>
команда была завершена сигналом;
следующее число это сигнал, завершивший команду.
</li>

</ul>

<p>
Когда вызвана без <code>command</code>,
<code>os.execute</code> возвращет логическое значение,
которое равно true, если оболочка (shell) доступна.


<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>

<p>
Вызывает ISO&nbsp;C функцию <code>exit</code> для завершения хостовой программы.
Если <code>code</code> = <b>true</b>,
возвращается статус <code>EXIT_SUCCESS</code>;
если <code>code</code> = <b>false</b>,
возвращается статус <code>EXIT_FAILURE</code>;
если <code>code</code> это число,
возвращается статус равный этому числу.
По умолчанию, <code>code</code> = <b>true</b>.

<p>
Если опциональный второй аргумент <code>close</code> = true,
закрывает Lua состояние перед выходом.


<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>

<p>
Возвращает значение переменной окружения процесса <code>varname</code>,
или <b>nil</b>, если переменная не определена.


<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>

<p>
Удаляет файл (или пустую директорию, на POSIX системах)
с переданным именем.
Если функция терпит неудачу, она возвращает <b>nil</b>,
сообщение об ошибке и код ошибки.


<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>

<p>
Переименовывает файл или директорию <code>oldname</code> в <code>newname</code>.
Если функция терпит неудачу, она возвращает <b>nil</b>,
сообщение об ошибке и код ошибки.

<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>

<p>
Устанавливает текущую локаль для программы.
<code>locale</code> - системозависимая строка, определяющая локаль;
<code>category</code> - опциональная строка, описывающая какую категорию изменять:
<code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>,
<code>"monetary"</code>, <code>"numeric"</code> или <code>"time"</code>;
по умолчанию category = <code>"all"</code>.
Функция возвращает имя новой локали,
или <b>nil</b>, если запрос не может быть выполнен.

<p>
Если <code>locale</code> это пустая строка,
текущая локаль устанавливается в засимую от реализации родную локаль.
Если <code>locale</code> это строка "<code>C</code>",
текущая локаль устанавливается в стандартную C локаль.

<p>
Когда вызвана с <b>nil</b> в качестве первого аргумента,
эта функция только возвращает имя текущей локали для данной категории.

<p>
Эта функция может не быть потокобезопасной,
т.к. использует C&nbsp;функцию <code>setlocale</code>.


<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>

<p>
Возвращает текущее время, когда вызвана без аргуменов,
или время, представляющее локальную дату и время определенные в переданной таблице.
Эта таблица должна иметь поля <code>year</code>, <code>month</code> и <code>day</code>,
и может иметь поля
<code>hour</code> (по умолчанию, 12),
<code>min</code> (по умолчанию, 0),
<code>sec</code> (по умолчанию, 0)
и <code>isdst</code> (по умолчанию, <b>nil</b>).
Остальные поля игнорируются.
Для описания этих полей, см. функцию <a href="#pdf-os.date"><code>os.date</code></a>.

<p>
Значения этих полей могут не быть в своих правильных диапазонах.
Например, если <code>sec</code> = -10,
то это означает -10 секунд от времени, определенного другими полями;
если <code>hour</code> = 1000,
это означает +1000 часов от времени, определенного другими полями.

<p>
Возвращенное значение это число, значение которого зависит от вашей системы.
В POSIX, Windows и некоторых других системах
это количество секунд, прошедших с какого-то определенного времени ("эпоха").
В других системах, значение не определено,
и число, возвращенное функцией <code>time</code>, может использоваться только, как аргумент
для <a href="#pdf-os.date"><code>os.date</code></a>
и <a href="#pdf-os.difftime"><code>os.difftime</code></a>.


<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>

<p>
Возвращает строку с именем файла, который может быть использован,
как временный.
Файл должен быть явно открыт перед использованием
и явно удален, когда больше не нужен.

<p>
На POSIX системах
эта функция также создает файл с этим именем,
для избежания рисков беззопасности.
(Кто-нибудь другой может создать файл с неправильными разрешениями
в промежуток времени между получением имени файла и его созданием.)
Вы по прежнему должны открыть файл для его использования
и удалить его (даже если не использовали).

<p>
Когда возможно,
предпочтительно использовать функцию <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,
которая автоматически удаляет файл при завершении программы.



<h2>6.10 &ndash; <a name="6.10">Библиотека отладки</a></h2>

<p>
Эта библиотека предоставляет Lua программам функциональность отладочного интерфейса
(<a href="#4.9">&sect;4.9</a>).
Используя эту библиотеку, вы должны проявлять внимательность.
Различные функции этой билиотеки нарушают базовые предположения
о Lua коде
(например, что локальные переменные функции не могут быть доступны снаружи;
что метатаблицы пользовательских данных не могут изменяться Lua кодом;
что Lua программы не падают)
и следовательно могут скомпрометировать защищенный код.
Кроме того, некоторые функции в этой библиотеке могут быть медленными.

<p>
Все функции в этой библиотеке предоставляются в таблице
<a name="pdf-debug"><code>debug</code></a>.
Все функции, которые оперируют с потоком,
имеют опциональный первый аргумент, определяющий поток.
По умолчанию, это всегда текущий поток.


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>

<p>
Входит в интерактивный режим с пользователем,
запуская каждую строку, вводимую пользователем.
Используя простые команды и другие отладочные возможности,
пользователь может проверять глобальные и локальные переменные,
изменять их значения, вычислять выражения и т.д.
Строка, содержащая только слово <code>cont</code>, завершает эту функцию,
так что вызывающий продожает своё исполнение.

<p>
Учтите, что команды для <code>debug.debug</code>
не являются лексически вложенными ни в одну функцию
и не имеют прямого доступа к локальным переменным.


<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>

<p>
Возвращает настройки текущего перехватчика потока, как три значения:
текущая функция-перехватчик, текущая маска перехвата и
текущий счетчик перехвата
(как установлено функцией <a href="#pdf-debug.sethook"><code>debug.sethook</code></a>).

<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>

<p>
Возвращает таблицу с информацией о функции.
Вы можете передать функцию напрямую
или можете передать число, как значение <code>f</code>,
которое означает функцию, выполняющуюся на уровне <code>f</code>
стека вызовов данного потока thread:
уровень&nbsp;0 - текущая функция (непосредственно <code>getinfo</code>);
уровень&nbsp;1 - функция, которая вызвала <code>getinfo</code>
(за исключением хвостовых вызовов, которые не считаются на стеке);
и так далее.
Если число <code>f</code> больше количества активных функций,
то <code>getinfo</code> возвращает <b>nil</b>.

<p>
Возвращенная таблица может содержать все поля возвращаемые <a href="#lua_getinfo"><code>lua_getinfo</code></a>,
со строкой <code>what</code>, описывающей какие поля заполнены.
По умолчанию, <code>what</code> установлена для получения всей доступной информации,
кроме таблицы значимых строк.
Если передана, опция '<code>f</code>'
добавляет поле <code>func</code> с функцией непосредственно.
Если передана, опция '<code>L</code>'
добавляет поле <code>activelines</code>
с таблицей значимых строк.

<p>
Например, выражение <code>debug.getinfo(1,"n").name</code> возвращает
имя текущей функции, если разумное имя существует,
и выражение <code>debug.getinfo(print)</code> возвращает
таблицу со всей доступной информацией о функции
<a href="#pdf-print"><code>print</code></a>.


<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>

<p>
Эта функция возвращает имя и значение локальной переменной с индексом
<code>local</code> функции на уровне <code>f</code> стека вызовов.
Эта функция получает доступ не только к явным локальным переменным,
но также к параметрам, временным переменныи и др.

<p>
Первый параметр или локальная переменная имеет индекс&nbsp;1, и так далее,
следуя порядку определения в коде,
считаются только активные переменные в текущей области функции.
Отрицательные индексы ссылаются на переменные (vararg) параметры;
-1 первый переменный параметр.
Функция возвращает <b>nil</b>, если нет переменной по данному индексу,
и вызывает ошибку, когда вызвана с уровнем за пределами диапазона.
(Вы можете вызвать <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a>
чтобы проверить, какой уровень допустим.)

<p>
Имена переменных, начинающиеся с '<code>(</code>' (открывающая скобка) 
представляют переменные с неизвестными именами
(внутренние переменные, такие как переменные управления циклом,
и переменные из кусков, сохраненных без отладочной информации).

<p>
Параметр <code>f</code> также может быть функцией.
В этом случае <code>getlocal</code> возвращает только имена параметров функции.


<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>

<p>
Возвращает метатаблицу переданного значения <code>value</code>
или <b>nil</b>, если у значения нет метатаблицы.


<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>

<p>
Возвращает таблицу реестра (см. <a href="#4.5">&sect;4.5</a>).

<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>

<p>
Эта функция возвращает имя и значение upvalue
с индексом <code>up</code> функции <code>f</code>.
Функция возвращает <b>nil</b>, если по данному индексу нет upvalue.

<p>
Имена переменных, начинающиеся с символа '<code>(</code>' (открывающая скобка) ,
представляют переменные с неизвестными именами
(переменные из кусков, сохраненных без отладочной информации).

<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>

<p>
Возвращает Lua значение, ассоциированное с <code>u</code>.
Если <code>u</code> не пользовательские данные,
возвращает <b>nil</b>.

<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>

<p>
Устанавливает переданную функцию, как перехватчик.
Строка <code>mask</code> и число <code>count</code> описывают,
когда будет вызыван перехватчик.
Строка mask может содержать комбинацию следующих символов:

<ul>
<li><b>'<code>c</code>': </b> перехватчик вызывается каждый раз, когда Lua вызывает функцию;</li>
<li><b>'<code>r</code>': </b> перехватчик вызывается каждый раз, когда Lua возвращается из функции;</li>
<li><b>'<code>l</code>': </b> перехватчик вызывается каждый раз, когда Lua входит на новую линию кода.</li>
</ul><p>
Кроме того, с <code>count</code> не равным нулю,
перехватчик вызывается также через каждые <code>count</code> инструкций
(count в значении "количество").

<p>
Когда вызвана без аргументов,
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> выключает перехват.

<p>
Когда вызван перехватчик, его первый параметр - это строка,
описывающая событие, которое стало причиной вызова перехватчика:
<code>"call"</code> (или <code>"tail call"</code>),
<code>"return"</code>,
<code>"line"</code> и <code>"count"</code>.
Для событий строк,
перехватчик также получает номер строки во втором параметре.
Внутри перехватчика
вы можете вызвать <code>getinfo</code> с уровнем&nbsp;2
для получения информации о запущенной функции
(уровень&nbsp;0 - это функция <code>getinfo</code>,
уровень&nbsp;1 - это функция-перехватчик).

<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>

<p>
Эта функция присваивает значение <code>value</code> локальной переменной
по индексу <code>local</code> функции на уровне <code>level</code> в стеке вызовов.
Функция возвращает <b>nil</b>, если локальная переменная с данным индексом не существует,
и генерирует ошибку, когда вызвана с <code>level</code> вне диапазона.
(Вы можете использовать <code>getinfo</code>
чтобы проверить какой уровень допустим.)
Иначе, возвращает имя локальной переменной.

<p>
См. <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>
для дополнительной информации о именах и индексах переменных.


<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>

<p>
Устанавливает <code>table</code> метатаблицей для <code>value</code>
(<code>table</code> может быть равно <b>nil</b>).
Возвращает <code>value</code>.

<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>

<p>
Эта функция присваивает значение <code>value</code> в upvalue
с индексом <code>up</code> функции <code>f</code>.
Функция возвращает <b>nil</b>, если по данному индексу нет upvalue.
Иначе, возвращает имя upvalue.

<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>

<p>
Устанавливает переданное значение <code>value</code>,
как Lua значение, ассоциированное с <code>udata</code>.
<code>udata</code> должно быть полными пользовательскими данными.

<p>
Возвращает <code>udata</code>.


<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>

<p>
Если <code>message</code> передано, но не строка и не <b>nil</b>,
эта функция возвращет <code>message</code> без дальнейшей обработки.
Иначе, возвращает строку с трассировкой стека вызовов.
Опциональная строка <code>message</code>
добавляется в начале трассировки стека.
Опциональное число <code>level</code> говорит,
на каком уровне начинать трассировку
(по умолчанию равен 1 - функция, вызвавшая <code>traceback</code>).


<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>

<p>
Возвращает уникальный идентификатор (как лёгкие пользовательские данные)
для upvalue под номером <code>n</code> из переданной функции.

<p>
Эти уникальные идентификаторы позволяют программе проверить,
когда разные замыкания совместно используют одни upvalue.
Lua замыкания, которые совместно используют upvalue
(т.е. имеют доступ к одной внешней локальной переменной)
вернут одинаковые идентификаторы для этих upvalue.


<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>

<p>
Заставляет <code>n1</code>-е upvalue Lua замыкания <code>f1</code>
ссылаться на <code>n2</code>-е upvalue Lua замыкания <code>f2</code>.



<h1>7 &ndash; <a name="7">Интерпретатор Lua</a></h1>

<p>
Хотя Lua был разработан, как язык расширений,
чтобы встраивать в хостовую C&nbsp;программу,
он также часто используется, как автономный язык.
Интерпретатор Lua, как автономного языка,
называется просто <code>lua</code> и предоставляется в стандартном дистрибутиве.
Автономный интерпретатор включает все стандартные библиотеки,
в том числе отладочную библиотеку.
Синтаксис командной строки:

<pre>
     lua [options] [script [args]]
</pre><p>
Опции:

<ul>
<li><b><code>-e <em>stat</em></code>: </b> запускает строку <em>stat</em>;</li>
<li><b><code>-l <em>mod</em></code>: </b> загружает (require) <em>mod</em>;</li>
<li><b><code>-i</code>: </b> входит в интерактивный режим после запуска <em>script</em>;</li>
<li><b><code>-v</code>: </b> печатает информацию о версии;</li>
<li><b><code>-E</code>: </b> игнорирует переменные окружения;</li>
<li><b><code>--</code>: </b> останавливает обработку опций;</li>
<li><b><code>-</code>: </b> запускает <code>stdin</code> как файл и останавливает обработку опций.</li>
</ul><p>
После обработки опций, <code>lua</code> запускает переданный <em>скрипт</em> (script).
Когда вызван без аргументов,
<code>lua</code> ведет себя, как <code>lua -v -i</code>,
когда стандартный ввод (<code>stdin</code>) это терминал;
и как <code>lua -</code> иначе.

<p>
Когда вызван без опции <code>-E</code>,
интерпретатор проверяет переменную окружения <a name="pdf-LUA_INIT_5_3"><code>LUA_INIT_5_3</code></a>
(или <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>, если предыдущая не определена)
перед запуском аргументов.
Если содержимое переменной имеет формат <code>@<em>filename</em></code>,
то <code>lua</code> запускает это файл.
Иначе, <code>lua</code> запускает непосредственно эту строку.

<p>
Когда запущен с опцией <code>-E</code>,
вместе с игнорированием <code>LUA_INIT</code>,
Lua также игнорирует значения <code>LUA_PATH</code> и <code>LUA_CPATH</code>,
устанавливая значения
<a href="#pdf-package.path"><code>package.path</code></a> и
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
путями по умолчанию, определенными в <code>luaconf.h</code>.

<p>
Все опции обрабатываются по порядку, кроме <code>-i</code> и <code>-E</code>.
Например, вызов

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
сначала установит <code>a</code> = 1, затем напечатает значение <code>a</code>,
и наконец запустит файл <code>script.lua</code> без аргументов.
(Здесь <code>$</code> - это приглашение командной строки.
Ваше приглашение может отличаться.)

<p>
Перед запуском любого кода
<code>lua</code> собирает все аргументы командной строки
в глобальной таблице <code>arg</code>.
Имя скрипта идет под индексом 0,
первый аргумент после имени скрипта идет по индексу 1, и т.д.
Все аргументы перед именем скрипта
(т.е имя интерпретатора и его опции)
находятся по отрицательным индексам.
Например, вызов

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
даст таблицу:

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
Если в вызове нет скрипта,
имя интерпретатора идет по индексу 0, далее идут другие аргументы.
Например, вызов

<pre>
     $ lua -e "print(arg[1])"
</pre><p>
напечатает "<code>-e</code>".
Если есть скрипт, то он вызывается с параметрами
<code>arg[1]</code>, &middot;&middot;&middot;, <code>arg[#arg]</code>.
(Как все куски в Lua,
скрипт компилируется, как функция с переменным числом аргументов.)

<p>
В интерактивном режиме, Lua многократно выдает приглащение и ждет ввода строки.
После ввода строки,
Lua сначала пробует интерпретировать строку как выражение.
В случае успеха, печатает её значение.
Иначе, интерпретирует строку как оператор.
Если вы напишете незавершенное выражение,
интерпретатор будет ждать его завершения, выдывая приглашение.

<p>
В случае незащищенных ошибок в скрипте,
интерпретатор пишет ошибку в стандартный поток ошибок.
Если объект ошибки это не строка, но имеет метаметод <code>__tostring</code>,
интерпретатор вызывает этот метаметод для выдачи финального сообщения.
Иначе, интерпретатор конвертирует объект ошибки в строку
и добавляет к нему трассировку стека.

<p>
При нормальном завершении
интерпретатор закрывает своё главное Lua состояние
(см. <a href="#lua_close"><code>lua_close</code></a>).
Скрипт может избежать этого шага, вызвав
<a href="#pdf-os.exit"><code>os.exit</code></a> для завершения.

<p>
Чтобы использовать Lua, как интерпретатор скриптов в Unix системах,
автономный интерпретатор пропускает первую линию куска,
если он начинается с символа <code>#</code>.
Следовательно, Lua скрипты могут быть сделаны исполняемыми программами,
используя <code>chmod +x</code> и&nbsp;<code>#!</code> форму,
например

<pre>
     #!/usr/local/bin/lua
</pre><p>
(Конечно, расположение Lua интерпретатора может быть другим.
Если <code>lua</code> в вашей переменной <code>PATH</code>,
то

<pre>
     #!/usr/bin/env lua
</pre><p>
более портабельное решение.)



<h1>8 &ndash; <a name="8">Несовместимости с предыдущей версией</a></h1>

<p>
Здесь приведен список несовместимостей, которые вы можете встретить при
портировании программы с Lua&nbsp;5.2 в Lua&nbsp;5.3.
Вы можете избежать некоторые несовместимости, скомпилировав Lua
с соответствующими опциями (см. файл <code>luaconf.h</code>).
Тем не менее, все эти опции совметимости будут убраны в будущем.

<p>
Версии Lua всегда могут изменить C API способами,
которые не подразумевают изменение исходного кода программы,
такие, как цифровые значения констант или реализация функций через макросы.
Следовательно, вы не должны ожидать бинарной совметимости между
разными версиями Lua.
Всегда перекомпилируйте клиентов Lua API,
когда используете новую версию.

<p>
Аналогично, версии Lua всегда могут изменить внутреннее представление
скомпилированных кусков;
скомпилированные куски не совместимы между разными версиями Lua.

<p>
Стандартные пути в официальном дистрибутиве могут меняться
между версиями.


<h2>8.1 &ndash; <a name="8.1">Изменения в языке</a></h2>
<ul>

<li>
Главное различие между Lua&nbsp;5.2 и Lua&nbsp;5.3
это введение подтипа целых для чисел.
Хотя это изменение не влияет на "нормальные" вычисления,
некоторые вычисления (главным образом это некоторые типы переполнений)
могут давать разные результаты.

<p>
Вы можете убрать эти отличия, принудительно сделав числа вещественными
(в Lua&nbsp;5.2 все числа вещественные),
в частности записывая константы с завершающим <code>.0</code>
или используя <code>x = x + 0.0</code> для преобразования переменных.
(Эта рекомендация только для быстрого исправления редких несовместимостей;
это не общая рекомендация для хорошего программирования.
Для хорошего программирования,
используйте вещественные числа там, где нужны вещественные,
и целые там, где нужны целые.)
</li>

<li>
Преобразование вещественных чисел в строку теперь добавляет суффикс <code>.0</code>
в результат, если он выглядит как целое.
(Например, вещественное 2.0 будет напечатано как <code>2.0</code>,
не как <code>2</code>.)
Вы всегда должны использовать явный фомат,
когда нуждаетесь в специфическом формате для чисел.

<p>
(Формально, это не несовместимость,
т.к. Lua не определяет, как числа форматируются в строки,
но некоторые программы предполагают что это специфический формат.)
</li>

<li>
Генерационный режим работы сборщика мусора был удален.
(Это была экспериментальная возможность в Lua&nbsp;5.2.)
</li>

</ul>



<h2>8.2 &ndash; <a name="8.2">Изменения в библиотеках</a></h2>
<ul>

<li>
Библиотека <code>bit32</code> стала нежелательной.
Легко загрузить совместимую внешнюю библиотеку или лучше
заменить её функции соответствующими битовыми операторами.
(Помните, что <code>bit32</code> оперирует с 32-битными целыми,
а битовые операторы Lua&nbsp;5.3 оперируют с целыми Lua,
которые по умолчанию имеют 64&nbsp;бита.)
</li>

<li>
Табличная библиотека теперь уважает метаметоды для установки и получения элементов.
</li>

<li>
Итератор <a href="#pdf-ipairs"><code>ipairs</code></a>
теперь уважает метаметоды и его метаметод <code>__ipairs</code>
стал нежелательным.
</li>

<li>
Имена опций в <a href="#pdf-io.read"><code>io.read</code></a>
больше не имеют начального символа '<code>*</code>'.
Для совместимости Lua продолжит принимать (и игнорировать) этот символ.
</li>

<li>
Следующие функции стали нежелательными в математической библиотеке:
<code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>pow</code>,
<code>frexp</code> и <code>ldexp</code>.
Вы можете заменить <code>math.pow(x,y)</code> на <code>x^y</code>;
вы можете заменить <code>math.atan2</code> на <code>math.atan</code>,
который теперь принимает один или два параметра;
вы можете заменить <code>math.ldexp(x,exp)</code> на <code>x * 2.0^exp</code>.
Для других операций вы можете также использовать внешнюю библиотеку
или реализовать их в Lua.
</li>

<li>
Искатель для C загрузчиков, используемый <a href="#pdf-require"><code>require</code></a>,
изменил способ обработки имен с версиями.
Сейчас версия должна идти после имени модуля
(как обычно в большинстве других инструментов).
Для совместимости, этот искатель все еще пытается использовать старый формат,
если не может найти функцию открытия соответствующую новому стилю.
(Lua&nbsp;5.2 уже работает таким способом, но это не документировано.)
</li>

<li>
Вызов <code>collectgarbage("count")</code>
сейчас возвращает только один результат.
(Вы можете вычислить второй результат из дробной части первого результата.)
</li>

</ul>



<h2>8.3 &ndash; <a name="8.3">Изменения в API</a></h2>

<ul>

<li>
Функции продолжения сейчас принимают как параметры то,
что им нужно было получать через <code>lua_getctx</code>,
так функция <code>lua_getctx</code> была удалена.
Откорректируйте ваш код соответственно.
</li>

<li>
Функция <a href="#lua_dump"><code>lua_dump</code></a>
имеет дополнительный параметр <code>strip</code>.
Используйте 0 для этого параметра, чтобы получить старое поведение.
</li>

<li>
Функции для вставки/получения беззнаковых целых
(<code>lua_pushunsigned</code>, <code>lua_tounsigned</code>, <code>lua_tounsignedx</code>,
<code>luaL_checkunsigned</code>, <code>luaL_optunsigned</code>)
нежелательны.
Используйте их знаковые эквиваленты с преобразованием типа.
</li>

<li>
Макросы для получения нестандартных целых типов
(<code>luaL_checkint</code>, <code>luaL_optint</code>, <code>luaL_checklong</code>, <code>luaL_optlong</code>)
нежелательны.
Используйте их эквиваленты с <a href="#lua_Integer"><code>lua_Integer</code></a>
с преобразованием типов
(или, когда возможно, используйте <a href="#lua_Integer"><code>lua_Integer</code></a> в вашем коде).
</li>

</ul>


<h1>9 &ndash; <a name="9">Полный синтаксис Lua</a></h1>

<p>
Здесь приведен полный синтаксис Lua в БНФ.
Как обычно в расширенной БНФ,
{A} означает 0 или более A,
и [A] означает опциональное A.
(Для приоритета операторов, см. <a href="#3.4.8">&sect;3.4.8</a>;
для описания терминалов Name, Numeral и LiteralString, см. <a href="#3.1">&sect;3.1</a>.)

<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; | 
		 varlist &lsquo;<b>=</b>&rsquo; explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist] 

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name 

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | &lsquo;<b>...</b>&rsquo; | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args 

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::=  &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; | 
		 &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo; | 
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; | 
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo; | &lsquo;<b>~</b>&rsquo;

</pre>

<p>

<P CLASS="footer">
Last update:
Wed Jun 10 18:31:15 BRT 2015 Last change: revised for Lua 5.3.1
</P>

</body></html>
